<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="DoxyPress 1.7.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>modm API documentation: Resumable Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxypress.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="custom_dark_theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by DoxyPress -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">modm API documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by DoxyPress 1.7.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__modm__processing__resumable.html',''); initResizable(); });
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
    <div class="title">Resumable Functions<div class="ingroups"><a class="el" href="group__modm__processing.html">Processing</a></div></div>
  </div>
  <div class="clear-floats"></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="memitem:gac8a210fcd55041e209c715e6c2d20046"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__processing__resumable.html#gac8a210fcd55041e209c715e6c2d20046">RF_BEGIN</a>(index)</td></tr>
<tr class="separator:gac8a210fcd55041e209c715e6c2d20046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb13fb5ba3b91305efb86b131157b7e1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__processing__resumable.html#gadb13fb5ba3b91305efb86b131157b7e1">RF_BEGIN</a>()</td></tr>
<tr class="separator:gadb13fb5ba3b91305efb86b131157b7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb13fb5ba3b91305efb86b131157b7e1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__processing__resumable.html#gadb13fb5ba3b91305efb86b131157b7e1">RF_BEGIN</a>()</td></tr>
<tr class="separator:gadb13fb5ba3b91305efb86b131157b7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1745c95144f51f29308d9b7e743e45d1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__processing__resumable.html#ga1745c95144f51f29308d9b7e743e45d1">RF_END_RETURN</a>(...)</td></tr>
<tr class="separator:ga1745c95144f51f29308d9b7e743e45d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2052f0001fb0e336a076e5e2c9ef769e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__processing__resumable.html#ga2052f0001fb0e336a076e5e2c9ef769e">RF_END</a>()</td></tr>
<tr class="separator:ga2052f0001fb0e336a076e5e2c9ef769e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83f010ad2d7b0998799ecd86807c7a70"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__processing__resumable.html#ga83f010ad2d7b0998799ecd86807c7a70">RF_END_RETURN_CALL</a>(...)</td></tr>
<tr class="separator:ga83f010ad2d7b0998799ecd86807c7a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50fda47255530910b40d0e883b097f68"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__processing__resumable.html#ga50fda47255530910b40d0e883b097f68">RF_YIELD</a>()</td></tr>
<tr class="separator:ga50fda47255530910b40d0e883b097f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68cd2b755f73a6ac41bce99ce0b578fa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__processing__resumable.html#ga68cd2b755f73a6ac41bce99ce0b578fa">RF_WAIT_THREAD</a>(...)</td></tr>
<tr class="separator:ga68cd2b755f73a6ac41bce99ce0b578fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bf05ac795a741fb25b3bdb1ed8062a2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__processing__resumable.html#ga5bf05ac795a741fb25b3bdb1ed8062a2">RF_WAIT_WHILE</a>(...)</td></tr>
<tr class="separator:ga5bf05ac795a741fb25b3bdb1ed8062a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bad5403d1965ff723f207d3e661bb9c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__processing__resumable.html#ga3bad5403d1965ff723f207d3e661bb9c">RF_WAIT_UNTIL</a>(...)</td></tr>
<tr class="separator:ga3bad5403d1965ff723f207d3e661bb9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66ca200383c3e8f34f8ea4f596cd85c7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__processing__resumable.html#ga66ca200383c3e8f34f8ea4f596cd85c7">RF_CALL</a>(...)</td></tr>
<tr class="separator:ga66ca200383c3e8f34f8ea4f596cd85c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67e057d64cf6211e0449fc37c4deb5c0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__processing__resumable.html#ga67e057d64cf6211e0449fc37c4deb5c0">RF_CALL_BLOCKING</a>(...)</td></tr>
<tr class="separator:ga67e057d64cf6211e0449fc37c4deb5c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga598af72b23d3556c1d276b6f52b4d900"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__processing__resumable.html#ga598af72b23d3556c1d276b6f52b4d900">RF_RETURN_CALL</a>(...)</td></tr>
<tr class="separator:ga598af72b23d3556c1d276b6f52b4d900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd9d967ce3835b43f6ef1629227a06ad"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__processing__resumable.html#gacd9d967ce3835b43f6ef1629227a06ad">RF_RETURN</a>(...)</td></tr>
<tr class="separator:gacd9d967ce3835b43f6ef1629227a06ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54fc1b0233a63e45b8569adcbbd13a78"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga54fc1b0233a63e45b8569adcbbd13a78"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga54fc1b0233a63e45b8569adcbbd13a78"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__modm__processing__resumable.html#ga54fc1b0233a63e45b8569adcbbd13a78">modm::ResumableResult</a> = T</td></tr>
<tr class="memdesc:ga54fc1b0233a63e45b8569adcbbd13a78"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmodm_1_1Resumable.html" title="Resumable functions implemented via fibers are normal functions. ">Resumable</a> functions implemented via fibers return like a normal function. <br /></td></tr>
<tr class="separator:ga54fc1b0233a63e45b8569adcbbd13a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>lbuild module: <code>modm:processing:resumable</code></p>
<dl class="section warning"><dt>Warning</dt><dd>Resumable Functions are deprecated! Unfortunately GCC12 is the last version that supported the way we implemented Resumables. Since GCC13 the implementation does not compile anymore and cannot be fixed without significant breaking changes. Please port your code to use <a href="group__modm__processing__fiber.html"><code>modm:processing:fiber</code></a> instead.</dd></dl>
<p>An implementation of lightweight resumable functions which allow for nested calling.</p>
<p>This base class and its macros allows you to implement and use several resumable functions in one class. This allows you to modularize your code by placing it into its own resumable functions instead of the placing everything into one big method. It also allows you to call and run resumable functions within your resumables, so you can reuse their functionality.</p>
<p>Note that you should call resumable functions within a protothreads, with the <code>PT_CALL(group.resumable())</code> macro, which will return the result of the resumable function. To call a resumable function inside another resumable function, use the <code><a class="el" href="group__modm__processing__resumable.html#ga66ca200383c3e8f34f8ea4f596cd85c7">RF_CALL</a>(group.resumable())</code>.</p>
<p>You may use the <code><a class="el" href="group__modm__processing__resumable.html#ga67e057d64cf6211e0449fc37c4deb5c0">RF_CALL_BLOCKING</a>(group.resumable())</code> macro to execute a resumable function outside of a protothread, however, this which will force the CPU to busy-wait until the resumable function ended.</p>
<dl class="section warning"><dt>Warning</dt><dd>Resumable functions are not thread-safe! Use an external mutex to arbitrate access if two Protothreads access the same resumable function.</dd></dl>
<p>You can either run your group of resumable functions independently from each other, or only run one function at a time, but it may nest calls to its own group's functions. So you need to inherit your group from <code><a class="el" href="classmodm_1_1Resumable.html" title="Resumable functions implemented via fibers are normal functions. ">modm::Resumable</a>&lt;#Functions&gt;</code>, and from <code><a class="el" href="classmodm_1_1NestedResumable.html" title="Resumable functions implemented via fibers are normal functions. ">modm::NestedResumable</a>&lt;#Functions&gt;</code> respectively.</p>
<h2>Independent operation</h2>
<p>You must begin each resumable function using <code><a class="el" href="group__modm__processing__resumable.html#gadb13fb5ba3b91305efb86b131157b7e1">RF_BEGIN(index)</a></code> where <code>index</code> is the unique index of your resumable function starting at zero. You may exit and return a value by using <code><a class="el" href="group__modm__processing__resumable.html#gacd9d967ce3835b43f6ef1629227a06ad">RF_RETURN(value)</a></code> or return the result of another resumable function using <code><a class="el" href="group__modm__processing__resumable.html#ga598af72b23d3556c1d276b6f52b4d900">RF_RETURN_CALL(resumable())</a></code>. This return value is wrapped in a <code>modm::ResumableResult&lt;Type&gt;</code> struct and transparently returned by the <code><a class="el" href="group__modm__processing__resumable.html#ga66ca200383c3e8f34f8ea4f596cd85c7">RF_CALL</a></code> macro so it can be used to influence your program flow. If the resumable function reaches <code><a class="el" href="group__modm__processing__resumable.html#ga2052f0001fb0e336a076e5e2c9ef769e">RF_END()</a></code> it will exit automatically, with the result of <code>0</code> cast to the return type. Should you wish to return a value at the end, you may use <code><a class="el" href="group__modm__processing__resumable.html#ga1745c95144f51f29308d9b7e743e45d1">RF_END_RETURN(value)</a></code>. You may also return the result of another resumable function using <code><a class="el" href="group__modm__processing__resumable.html#ga83f010ad2d7b0998799ecd86807c7a70">RF_END_RETURN_CALL(resumable())</a></code>.</p>
<p>Be aware that this class keeps a separate state for each of your resumable functions. This allows each resumable function to be run at the same time. This might require the use of an internal semaphore or mutex if such dependencies exist in your use case. Take a look at the <code>NestedResumable</code> class for mutually exclusive resumable functions, which also require a little less memory.</p>
<h2>Nested operation</h2>
<p>You are responsible to choosing the right nesting depth! This class will guard itself against calling another resumable function at too deep a nesting level and fail the <code>rf.nest</code> assertion! It is then up to you to recognize this in your program design and increase the nesting depth or rethink your code.</p>
<p>The resumable functions of this class are mutually exclusive, so only one resumable function of the same object can run at the same time. Even if you call another resumable function, it will simply return <code>modm::rf::WrongState</code>. Using the <code><a class="el" href="group__modm__processing__resumable.html#ga66ca200383c3e8f34f8ea4f596cd85c7">RF_CALL(resumable())</a></code> macro, you can wait for these resumable functions to become available and then run them, so you usually do not need to worry about those cases.</p>
<p>You must begin each resumable function using <code><a class="el" href="group__modm__processing__resumable.html#gadb13fb5ba3b91305efb86b131157b7e1">RF_BEGIN()</a></code>. You may exit and return a value by using <code><a class="el" href="group__modm__processing__resumable.html#gacd9d967ce3835b43f6ef1629227a06ad">RF_RETURN(value)</a></code> or return the result of another resumable function using <code><a class="el" href="group__modm__processing__resumable.html#ga598af72b23d3556c1d276b6f52b4d900">RF_RETURN_CALL(resumable())</a></code>. This return value is wrapped in a <code>modm::ResumableResult&lt;Type&gt;</code> struct and transparently returned by the <code><a class="el" href="group__modm__processing__resumable.html#ga66ca200383c3e8f34f8ea4f596cd85c7">RF_CALL</a></code> macro so it can be used to influence your program flow. If the resumable function reaches <code><a class="el" href="group__modm__processing__resumable.html#ga2052f0001fb0e336a076e5e2c9ef769e">RF_END()</a></code> it will exit automatically, with the result of <code>0</code> cast to the return type. Should you wish to return a value at the end, you may use <code><a class="el" href="group__modm__processing__resumable.html#ga1745c95144f51f29308d9b7e743e45d1">RF_END_RETURN(value)</a></code>. You may also return the result of another resumable function using <code><a class="el" href="group__modm__processing__resumable.html#ga83f010ad2d7b0998799ecd86807c7a70">RF_END_RETURN_CALL(resumable())</a></code>.</p>
<h2>Example</h2>
<p>Here is a (slightly over-engineered) example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;modm/platform.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;modm/processing.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>Led = GpioOutputB0;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>BlinkingLight : <span class="keyword">public</span> modm::pt::Protothread, <span class="keyword">private</span> <a class="code" href="classmodm_1_1NestedResumable.html">modm::NestedResumable</a>&lt;2&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">bool</span></div>
<div class="line">    run()</div>
<div class="line">    {</div>
<div class="line">        PT_BEGIN();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// set everything up</span></div>
<div class="line">        Led::setOutput();</div>
<div class="line">        Led::set();</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div>
<div class="line">        {</div>
<div class="line">            Led::set();</div>
<div class="line">            PT_CALL(waitForTimer());</div>
<div class="line"> </div>
<div class="line">            Led::reset();</div>
<div class="line">            PT_CALL(setTimer(200));</div>
<div class="line"> </div>
<div class="line">            PT_WAIT_UNTIL(timeout.isExpired());</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        PT_END();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="group__modm__processing__resumable.html#ga54fc1b0233a63e45b8569adcbbd13a78">modm::ResumableResult&lt;bool&gt;</a></div>
<div class="line">    waitForTimer()</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="group__modm__processing__resumable.html#gadb13fb5ba3b91305efb86b131157b7e1">RF_BEGIN</a>();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// nested calling is allowed</span></div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code" href="group__modm__processing__resumable.html#ga66ca200383c3e8f34f8ea4f596cd85c7">RF_CALL</a>(setTimer(100)))</div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="group__modm__processing__resumable.html#ga3bad5403d1965ff723f207d3e661bb9c">RF_WAIT_UNTIL</a>(timeout.isExpired());</div>
<div class="line">            <a class="code" href="group__modm__processing__resumable.html#gacd9d967ce3835b43f6ef1629227a06ad">RF_RETURN</a>(<span class="keyword">true</span>);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <a class="code" href="group__modm__processing__resumable.html#ga1745c95144f51f29308d9b7e743e45d1">RF_END_RETURN</a>(<span class="keyword">false</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="group__modm__processing__resumable.html#ga54fc1b0233a63e45b8569adcbbd13a78">modm::ResumableResult&lt;bool&gt;</a></div>
<div class="line">    setTimer(uint16_t new_timeout)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="group__modm__processing__resumable.html#gadb13fb5ba3b91305efb86b131157b7e1">RF_BEGIN</a>();</div>
<div class="line"> </div>
<div class="line">        timeout.restart(std::chrono::milliseconds(new_timeout));</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span>(timeout.isArmed()) {</div>
<div class="line">            <a class="code" href="group__modm__processing__resumable.html#gacd9d967ce3835b43f6ef1629227a06ad">RF_RETURN</a>(<span class="keyword">true</span>);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// clean up code goes here</span></div>
<div class="line"> </div>
<div class="line">        <a class="code" href="group__modm__processing__resumable.html#ga1745c95144f51f29308d9b7e743e45d1">RF_END_RETURN</a>(<span class="keyword">false</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    modm::ShortTimeout timeout;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">BlinkingLight light;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">    light.run();</div>
<div class="line">}</div>
</div><!-- end fragment -->
<p>For other examples take a look in the <code>examples</code> folder in the modm root folder. The given example is in <code>modm/examples/generic/resumable</code>.</p>
<h2>Using Fibers</h2>
<p>Resumable functions can be implemented using stackful fibers by setting the <code>modm:processing:protothread:use_fiber</code> option, which replaces the preprocessor macros and C++ implementations of this and the <code>modm:processing:protothreads</code> module with a fiber version.</p>
<p>Specifically, the <code>PT_*</code> and <code>RF_*</code> macros are now forwarding their arguments unmodified and instead relying on <code><a class="el" href="group__modm__architecture__fiber.html#gadaca0b8f126b33ceb0f470a56cc410cb">modm::this_fiber::yield()</a></code> for context switching:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define RF_YIELD() modm::this_fiber::yield()</span></div>
<div class="line"><span class="preprocessor">#define RF_WAIT_WHILE(cond) while(cond) { modm::this_fiber::yield(); }</span></div>
<div class="line"><span class="preprocessor">#define RF_CALL(func) func</span></div>
<div class="line"><span class="preprocessor">#define RF_RETURN(value) return value</span></div>
</div><!-- end fragment -->
<p>You may call <code><a class="el" href="group__modm__processing__resumable.html#ga67e057d64cf6211e0449fc37c4deb5c0">RF_CALL_BLOCKING(resumable)</a></code> outside a fiber context, in which case the <code><a class="el" href="group__modm__architecture__fiber.html#gadaca0b8f126b33ceb0f470a56cc410cb">modm::this_fiber::yield()</a></code> will return immediately, which is the same behavior as before.</p>
<p>However, the <code>modm::ResumableResult</code>, <code><a class="el" href="classmodm_1_1Resumable.html" title="Resumable functions implemented via fibers are normal functions. ">modm::Resumable</a></code>, and <code><a class="el" href="classmodm_1_1NestedResumable.html" title="Resumable functions implemented via fibers are normal functions. ">modm::NestedResumable</a></code> classes are now empty implementations:</p>
<div class="fragment"><div class="line"><span class="comment">// Only forwards the return value</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using </span><a class="code" href="group__modm__processing__resumable.html#ga54fc1b0233a63e45b8569adcbbd13a78">ResumableResult</a> = T;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Empty base classes</span></div>
<div class="line"><span class="keyword">template</span>&lt;u<span class="keywordtype">int</span>8_t Functions=0&gt; <span class="keyword">class </span>Resumable {};</div>
<div class="line"><span class="keyword">template</span>&lt;u<span class="keywordtype">int</span>8_t Levels=0&gt; <span class="keyword">class </span>NestedResumable {};</div>
</div><!-- end fragment -->
<p>There should be no modification necessary to the resumable functions itself.</p>
<h3>Restrictions</h3>
<p>There is one minor limitations when using fibers: 1) no nesting depth checking for <code>NestedResumable</code>, 2) stopping resumable functions is not implementable.</p>
<p>The nesting depth is limited by the stack size of the fiber, so it would manifest as a stack overflow, which would need to be checked differently.</p>
<p>The utility member functions</p><ul>
<li><code>Resumable::stopAllResumables()</code>,</li>
<li><code>Resumable::stopResumable(uint8_t)</code>, and</li>
<li><code>NestedResumable::stopResumable()</code> cannot be implemented using fibers as that would require the resumable to implement a cancellation point using <code><a class="el" href="classmodm_1_1fiber_1_1stop__token.html">modm::fiber::stop_token</a></code>. However, since there is no concept of this in the original API, it is simply missing and thus cannot be implemented transparently.</li>
</ul>
<h2>Module Options</h2>
<h3>modm:processing:resumable:check_nesting_depth: Check nesting call depth</h3>
<p>Nested resumable functions protect against memory corruption by checking if the nesting level is within the allocated nesting level depth, on first entry to the function. If the allocated nesting level is exceeded, the assertion <code>resumable.begin.nesting</code> fails.</p>
<p>You may disable this behavior by disabling this check, then instead of the assertion, the function on entry returns the <code>modm::rf::NestingError</code> state value. <code>PT_CALL()</code> and <code><a class="el" href="group__modm__processing__resumable.html#ga66ca200383c3e8f34f8ea4f596cd85c7">RF_CALL()</a></code> macros will respond to this error by stopping function polling and just continuing program execution.</p>
<dl class="section note"><dt>Note</dt><dd>Performance Penalty This check is performed during the call to <code><a class="el" href="group__modm__processing__resumable.html#gadb13fb5ba3b91305efb86b131157b7e1">RF_BEGIN(N)</a></code>, so exactly once on function entry and not during every polling call, so the performance penalty is relatively small.</dd></dl>
<p>Generated with: <code>yes in [yes, no]</code> </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gadb13fb5ba3b91305efb86b131157b7e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RF_BEGIN</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare start of resumable function with index. </p><dl class="section warning"><dt>Warning</dt><dd>Use at start of the <code>resumable()</code> implementation!</dd></dl>
<p>Declare start of a nested resumable function. This will immediately return if the nesting is too deep.</p>
<dl class="section warning"><dt>Warning</dt><dd>Use at start of the <code>resumable()</code> implementation! </dd></dl>

</div>
</div>
<a class="anchor" id="gadb13fb5ba3b91305efb86b131157b7e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RF_BEGIN</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare start of resumable function with index. </p><dl class="section warning"><dt>Warning</dt><dd>Use at start of the <code>resumable()</code> implementation!</dd></dl>
<p>Declare start of a nested resumable function. This will immediately return if the nesting is too deep.</p>
<dl class="section warning"><dt>Warning</dt><dd>Use at start of the <code>resumable()</code> implementation! </dd></dl>

</div>
</div>
<a class="anchor" id="gadb13fb5ba3b91305efb86b131157b7e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RF_BEGIN</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare start of resumable function with index. </p><dl class="section warning"><dt>Warning</dt><dd>Use at start of the <code>resumable()</code> implementation!</dd></dl>
<p>Declare start of a nested resumable function. This will immediately return if the nesting is too deep.</p>
<dl class="section warning"><dt>Warning</dt><dd>Use at start of the <code>resumable()</code> implementation! </dd></dl>

</div>
</div>
<a class="anchor" id="gadb13fb5ba3b91305efb86b131157b7e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RF_BEGIN</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare start of resumable function with index. </p><dl class="section warning"><dt>Warning</dt><dd>Use at start of the <code>resumable()</code> implementation!</dd></dl>
<p>Declare start of a nested resumable function. This will immediately return if the nesting is too deep.</p>
<dl class="section warning"><dt>Warning</dt><dd>Use at start of the <code>resumable()</code> implementation! </dd></dl>

</div>
</div>
<a class="anchor" id="gac8a210fcd55041e209c715e6c2d20046"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RF_BEGIN</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare start of resumable function with index. </p><dl class="section warning"><dt>Warning</dt><dd>Use at start of the <code>resumable()</code> implementation!</dd></dl>
<p>Declare start of a nested resumable function. This will immediately return if the nesting is too deep.</p>
<dl class="section warning"><dt>Warning</dt><dd>Use at start of the <code>resumable()</code> implementation! </dd></dl>

</div>
</div>
<a class="anchor" id="ga66ca200383c3e8f34f8ea4f596cd85c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RF_CALL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls a resumable function and returns its result. </p>

</div>
</div>
<a class="anchor" id="ga66ca200383c3e8f34f8ea4f596cd85c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RF_CALL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls a resumable function and returns its result. </p>

</div>
</div>
<a class="anchor" id="ga67e057d64cf6211e0449fc37c4deb5c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RF_CALL_BLOCKING</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls a resumable function, busy-waits and returns its result. </p>

</div>
</div>
<a class="anchor" id="ga67e057d64cf6211e0449fc37c4deb5c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RF_CALL_BLOCKING</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls a resumable function, busy-waits and returns its result. </p>

</div>
</div>
<a class="anchor" id="ga2052f0001fb0e336a076e5e2c9ef769e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RF_END</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>End the resumable function. You can use this to return <code>void</code>, or if the result does not matter.</p>
<dl class="section warning"><dt>Warning</dt><dd>Use at end of the <code>resumable()</code> implementation only! </dd></dl>

</div>
</div>
<a class="anchor" id="ga2052f0001fb0e336a076e5e2c9ef769e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RF_END</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>End the resumable function. You can use this to return <code>void</code>, or if the result does not matter.</p>
<dl class="section warning"><dt>Warning</dt><dd>Use at end of the <code>resumable()</code> implementation only! </dd></dl>

</div>
</div>
<a class="anchor" id="ga1745c95144f51f29308d9b7e743e45d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RF_END_RETURN</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>End the resumable function and return a result.</p>
<dl class="section warning"><dt>Warning</dt><dd>Use at end of the <code>resumable()</code> implementation only! </dd></dl>

</div>
</div>
<a class="anchor" id="ga1745c95144f51f29308d9b7e743e45d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RF_END_RETURN</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>End the resumable function and return a result.</p>
<dl class="section warning"><dt>Warning</dt><dd>Use at end of the <code>resumable()</code> implementation only! </dd></dl>

</div>
</div>
<a class="anchor" id="ga83f010ad2d7b0998799ecd86807c7a70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RF_END_RETURN_CALL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>End the resumable function by calling another resumable function and returning its result.</p>
<dl class="section warning"><dt>Warning</dt><dd>Use at end of the <code>resumable()</code> implementation only! </dd></dl>

</div>
</div>
<a class="anchor" id="ga83f010ad2d7b0998799ecd86807c7a70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RF_END_RETURN_CALL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>End the resumable function by calling another resumable function and returning its result.</p>
<dl class="section warning"><dt>Warning</dt><dd>Use at end of the <code>resumable()</code> implementation only! </dd></dl>

</div>
</div>
<a class="anchor" id="gacd9d967ce3835b43f6ef1629227a06ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RF_RETURN</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop and exit from resumable function with an optional result. </p>

</div>
</div>
<a class="anchor" id="gacd9d967ce3835b43f6ef1629227a06ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RF_RETURN</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop and exit from resumable function with an optional result. </p>

</div>
</div>
<a class="anchor" id="ga598af72b23d3556c1d276b6f52b4d900"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RF_RETURN_CALL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exits a resumable function and returns another resumable function's result. </p>

</div>
</div>
<a class="anchor" id="ga598af72b23d3556c1d276b6f52b4d900"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RF_RETURN_CALL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exits a resumable function and returns another resumable function's result. </p>

</div>
</div>
<a class="anchor" id="ga68cd2b755f73a6ac41bce99ce0b578fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RF_WAIT_THREAD</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cause resumable function to wait until given child protothread completes. </p>

</div>
</div>
<a class="anchor" id="ga68cd2b755f73a6ac41bce99ce0b578fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RF_WAIT_THREAD</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cause resumable function to wait until given child protothread completes. </p>

</div>
</div>
<a class="anchor" id="ga3bad5403d1965ff723f207d3e661bb9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RF_WAIT_UNTIL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cause resumable function to wait <b>until</b> given <code>condition</code> is true. </p>

</div>
</div>
<a class="anchor" id="ga3bad5403d1965ff723f207d3e661bb9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RF_WAIT_UNTIL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cause resumable function to wait <b>until</b> given <code>condition</code> is true. </p>

</div>
</div>
<a class="anchor" id="ga5bf05ac795a741fb25b3bdb1ed8062a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RF_WAIT_WHILE</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cause resumable function to wait <b>while</b> given <code>condition</code> is true. </p>

</div>
</div>
<a class="anchor" id="ga5bf05ac795a741fb25b3bdb1ed8062a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RF_WAIT_WHILE</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cause resumable function to wait <b>while</b> given <code>condition</code> is true. </p>

</div>
</div>
<a class="anchor" id="ga50fda47255530910b40d0e883b097f68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RF_YIELD</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Yield resumable function until next invocation. </p>

</div>
</div>
<a class="anchor" id="ga50fda47255530910b40d0e883b097f68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RF_YIELD</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Yield resumable function until next invocation. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for DoxyPress 1.3.7-->
<!-- Generated by DoxyPress 1.7.0 -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.copperspice.com/documentation-doxypress.html">
    <img class="footer" src="doxypress.png" alt="DoxyPress"/></a> 1.7.0 </li>
  </ul>
</div>
<script>
if (window.location.href.includes("modm.io")) {
 var device = /\/api\/([a-zA-Z0-9_-]+)\//.exec(window.location.href)[1].toUpperCase();
 document.title = document.title.replace("modm API documentation", "modm API documentation for " + device);
 document.getElementById('projectname').innerHTML = document.getElementById('projectname').innerHTML.replace("modm API documentation", "modm API documentation for " + device);
}
document.getElementById('MSearchResults').onload = function()
{
  var iframe = document.getElementById('MSearchResults').contentWindow.document;
  var head = iframe.getElementsByTagName("head")[0];
  var link = iframe.createElement("link");
  link.setAttribute("rel", "stylesheet");
  link.setAttribute("type", "text/css");
  link.setAttribute("href", "../custom.css");
  head.appendChild(link);
  var link = iframe.createElement("link");
  link.setAttribute("rel", "stylesheet");
  link.setAttribute("type", "text/css");
  link.setAttribute("href", "../custom_dark_theme.css");
  head.appendChild(link);
}
</script>
</body>
</html>
