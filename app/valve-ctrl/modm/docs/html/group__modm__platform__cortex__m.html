<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="DoxyPress 1.7.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>modm API documentation: ARM Cortex-M Core</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxypress.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="custom_dark_theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by DoxyPress -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">modm API documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by DoxyPress 1.7.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__modm__platform__cortex__m.html',''); initResizable(); });
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
    <div class="title">ARM Cortex-M Core<div class="ingroups"><a class="el" href="group__modm__platform.html">Platform HAL</a></div></div>
  </div>
  <div class="clear-floats"></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="memitem:ga8db0a6548d7164c9124a8c5d74eaf474"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__platform__cortex__m.html#ga8db0a6548d7164c9124a8c5d74eaf474">MODM_HARDWARE_INIT</a>(function)</td></tr>
<tr class="separator:ga8db0a6548d7164c9124a8c5d74eaf474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59ce8a5b1d0b4b3ea222937c93a1caa5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__platform__cortex__m.html#ga59ce8a5b1d0b4b3ea222937c93a1caa5">MODM_HARDWARE_INIT_NAME</a>(name,  function)</td></tr>
<tr class="separator:ga59ce8a5b1d0b4b3ea222937c93a1caa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga609c75050044610ef690ed86a16a92d4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__platform__cortex__m.html#ga609c75050044610ef690ed86a16a92d4">MODM_HARDWARE_INIT_ORDER</a>(function,  order)</td></tr>
<tr class="separator:ga609c75050044610ef690ed86a16a92d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5168e2a05059dd5a06987dfb15401f3b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__platform__cortex__m.html#ga5168e2a05059dd5a06987dfb15401f3b">MODM_HARDWARE_INIT_NAME_ORDER</a>(name,  function,  order)</td></tr>
<tr class="separator:ga5168e2a05059dd5a06987dfb15401f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>lbuild module: <code>modm:platform:cortex-m</code></p>
<p>This module generates the startup code, vector table, linkerscript as well as initialize the heap, deal with assertions, provide blocking delay functions, atomic and unaligned access and the GNU build ID.</p>
<p>Since this is only initializes the generic ARM Cortex-M parts, it delegates device-specific initialization to the <a href="group__modm__platform__core.html"><code>modm:platform:core</code></a> module. Please depend on that module directly instead of this one.</p>
<h2>Startup</h2>
<p>After reset, the ARM Cortex-M hardware jumps to the <code>Reset_Handler()</code>, which is implemented as follows:</p>
<ol type="1">
<li>The main stack pointer (MSP) is initialized by software.</li>
<li>Call <code>__modm_initialize_platform()</code> to initialize the device hardware.</li>
<li>Call <code>modm_initialize_platform()</code> to initialize the custom device hardware.</li>
<li>Copy data to internal RAM.</li>
<li>Zero sections in internal RAM.</li>
<li>Initialize ARM Cortex-M core: enable FPU, caches and relocate vector table.</li>
<li>Execute shared hardware initialization functions.</li>
<li>Copy data to <em>external</em> RAM.</li>
<li>Zero sections in <em>external</em> RAM.</li>
</ol>
<ol type="1">
<li>Initialize heap via <code>__modm_initialize_memory()</code> (implemented by the <code>modm:platform:heap</code> module).</li>
<li>Call static constructors.</li>
<li>Call <code>main()</code> application entry point.</li>
<li>If <code>main()</code> returns, assert on <code>main.exit</code> (only in debug profile).</li>
<li>Reboot if assertion returns.</li>
</ol>
<h3>Device Initialization</h3>
<p>The <code>__modm_initialize_platform()</code> function is called <em>directly</em> after reset, and its purpose is to initialize the device specific hardware, such as enable internal memories or disable the hardware watchdog timer. You can provide additional application-specific initialization by overwriting the weakly linked <code>modm_initialize_platform()</code> function:</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">void</span> modm_initialize_platform()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Configure power settings before accessing SRAM</span></div>
<div class="line">}</div>
</div><!-- end fragment -->
<p>It's important to understand that because the <code>.data</code> section has not yet been copied and the <code>.bss</code> section has not yet been zeroed, <b>there exists no valid C environment yet in this function context</b>! This means you cannot use any global variables, not even "local" static ones defined in your function, and depending on your hardware you may not even access read-only data (<code>const</code> variables, global OR local). In addition, if your linkerscript places the main stack pointer into a memory that is disabled on reset, you cannot even access the stack until you've enabled its backing memory. The <code>Reset_Handler</code> therefore calls this function in Assembly without accessing the stack.</p>
<p>It is strongly recommended to only read/write registers in this function, and perhaps even write this function in Assembly if deemed necessary.</p>
<h3>Cache Initialization</h3>
<p>For Cortex-M7 devices, the I-Cache is enabled by default. The D-Cache with a write-back write-allocate policy is only enabled if the <code>modm:platform:dma</code> module is NOT selected. modm currently does not support allocating DMA buffers in non-cachable regions or granular cache invalidation. See the <a href="https://www.keil.com/pack/doc/CMSIS_Dev/Core/html/group__cache__functions__m7.html">CMSIS-Core Cache API</a> for more information on cache management.</p>
<h3>Additional Initialization</h3>
<p>A few modules need to initialize additional hardware during booting. For example: your device has external memories connected that you want to use for the heap. You can create a function that configures the peripherals for these external memories and place <em>a pointer to this function</em> into a special linker section and the startup script will then call this function before heap initialization.</p>
<p>Since the hardware init functions are called <em>after</em> internal data initialization, you have a valid C environment and thus can access the device normally, but since the calls happen <em>before</em> external data and heap initialization <b>you cannot use the heap in these functions</b>!</p>
<p>You can give a relative global order to your init functions. Ordered init functions are called first, then unordered init functions are called in any order. Please note that order numbers 0 - 999 are reserved for use by modm or other libraries!</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> init_external_sdram()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// configure the hardware here</span></div>
<div class="line">}</div>
<div class="line"><span class="comment">// Startup script calls this function in any order, *after* prioritized functions!</span></div>
<div class="line"><a class="code" href="group__modm__platform__cortex__m.html#ga8db0a6548d7164c9124a8c5d74eaf474">MODM_HARDWARE_INIT</a>(init_external_sdram);</div>
<div class="line"><span class="comment">// If you need to pass a C++ function, you need to declare</span></div>
<div class="line"><a class="code" href="group__modm__platform__cortex__m.html#ga59ce8a5b1d0b4b3ea222937c93a1caa5">MODM_HARDWARE_INIT_NAME</a>(init_function_name, namespace::init_function);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// If you need to initialize in a certain order use numbers &gt;= 1000</span></div>
<div class="line"><a class="code" href="group__modm__platform__cortex__m.html#ga609c75050044610ef690ed86a16a92d4">MODM_HARDWARE_INIT_ORDER</a>(init_before_sdram1, 1000);</div>
<div class="line"><span class="comment">// called after init_before_sdram1, since it has a higher order number</span></div>
<div class="line"><a class="code" href="group__modm__platform__cortex__m.html#ga5168e2a05059dd5a06987dfb15401f3b">MODM_HARDWARE_INIT_NAME_ORDER</a>(init_before_sdram2, namespace::function, 1001);</div>
</div><!-- end fragment -->
<h2>Interrupt Vector Table</h2>
<p>The Cortex-M vector table (VTOR) is target-specific and generated using data from modm-devices. The main stack pointer is allocated according to the linkerscript and the <code>Reset_Handler</code> is defined by the startup script.</p>
<p>All handlers are weakly aliased to <code>Undefined_Handler</code>, which is called if an IRQ is enabled, but no handler is defined for it. This default handler determines the currectly active IRQ, sets its priority to the lowest level, and disables the IRQ from firing again and then asserts on <code>nvic.undef</code> with the (signed) IRQ number as context.</p>
<p>The lowering of the priority is necessary, since the assertion handlers (see <a href="group__modm__architecture__assert.html"><code>modm:architecture:assert</code></a>) are called from within this active IRQ and its priority should not prevent logging functionality (which might require a UART interrupt to flush data out) from working correctly.</p>
<h2>Linkerscript</h2>
<p>This module provides building blocks for GNU ld linkerscripts in the form of Jinja macros that the <a href="group__modm__platform__core.html"><code>modm:platform:core</code></a> module <em>assembles</em> into a linkerscript, depending on the memory architecture of the target chosen.</p>
<p>The following macros are available:</p>
<ul>
<li><code>copyright()</code>: Copyright notice.</li>
<li><code>prefix()</code>: Contains <code>MEMORY</code> sections, output format and entry symbol and stack size definitions.</li>
<li><code>section_vector_rom(memory)</code>: places the read-only vector table into ROM <code>memory</code>.</li>
<li><code>section_vector_ram(memory, table_copy)</code>: places the volatile vector table into RAM <code>memory</code> and add it to the copy table. You must satisfy alignment requirements externally.</li>
<li><code>section_load(memory, table_copy, sections)</code>: place each <code>.{section}</code> in <code>sections</code> into <code>memory</code> and add them the copy table.</li>
<li><code>section_stack(memory, start=None, suffix="")</code>: place the main stack into <code>memory</code> after moving the location counter to <code>start</code>. <code>suffix</code> can be used to add multiple <code>.stack{suffix}</code> sections.</li>
<li><code>section_heap(memory, name, placement=None, sections=[])</code>: Add the noload <code>sections</code> to <code>memory</code> and fill up remaining space in <code>memory</code> with heap section <code>.{name}</code>. Argument <code>placement</code> can be used to place the section into a larger continuous section of which <code>memory</code> is just a subsection. The <code>__{name}_end</code> will be the maximum of the location counter and the <code>memory</code> section end address, so that previous sections will push this section back.</li>
<li><code>all_heap_sections(table_copy, table_zero, table_heap, props={})</code>: places the heap sections as described by <code>cont_ram_regions</code> of the <code>linkerscript</code> query. This also adds bss and noinit sections into each region. The <code>props</code> key can be used to override the default <code>0x001f</code> memory properties.</li>
<li><code>section_rom(memory)</code>: place all read-only sections (<code>.text</code>, <code>.rodata</code> etc) into <code>memory</code>.</li>
<li><code>section_ram(memory, rom, table_copy, table_zero, sections_data=[], sections_bss=[], sections_noinit=[])</code>: place all volatile sections (<code>.data</code>, <code>.bss</code> etc) into <code>memory</code> and load from <code>rom</code>. Additional sections can be added.</li>
<li><code>section_tables(memory, copy, zero, heap)</code>: place the zero, copy and heap table into <code>memory</code>.</li>
<li><code>section_rom_start(memory)</code>: place at ROM start.</li>
<li><code>section_rom_end(memory)</code>: place at ROM end.</li>
<li><code>section_debug()</code>: place debug sections at the very end.</li>
</ul>
<p>Please consult the <a href="group__modm__platform__core.html"><code>modm:platform:core</code></a> documentation for the target-specific arrangement of these section macros and for potential limitations that the target's memory architecture poses.</p>
<h3>Section <code>.fastdata</code></h3>
<p>The <code>.fastdata</code> section is placed into a device specific data cache or into the fastest RAM. Please note that the <code>.fastdata</code> section may be placed into RAM that is only accessable to the Cortex-M core (via the Data-Bus), which can cause issues with DMA access. However, the <code>.fastdata</code> section is not required to be DMA-able and in such a case the developer needs to place the data into the generic <code>.data</code> section or choose a device with a DMA-able fast RAM.</p>
<h3>Section <code>.fastcode</code></h3>
<p>The <code>.fastcode</code> section is placed into a device specific instruction cache (via I-Code bus) or into the fastest executable RAM (via S-Bus).</p>
<p>From the Cortex-M3 Technical Reference Manual:</p>
<blockquote class="doxtable">
<p>&zwj;14.5 System Interface:</p>
<p>The system interface is a 32-bit AHB-Lite bus. Instruction and vector fetches, and data and debug accesses to the System memory space, 0x20000000 - 0xDFFFFFFF, 0xE0100000 - 0xFFFFFFFF, are performed over this bus.</p>
<p>14.5.6 Pipelined instruction fetches:</p>
<p>To provide a clean timing interface on the System bus, instruction and vector fetch requests to this bus are registered. This results in an additional cycle of latency because instructions fetched from the System bus take two cycles. This also means that back-to-back instruction fetches from the System bus are not possible.</p>
<p>Note: Instruction fetch requests to the ICode bus are not registered. Performance critical code must run from the ICode interface. </p>
</blockquote>
<h3>Adding Sections</h3>
<p>The default linkerscripts only describe the internal memory, however, they can be extended for external memories using the <code>linkerscript.*</code> collectors of this module. For example, to add an external 16MB SDRAM to your device and place a static data section there that is copied from flash and use the remainder for heap access, these steps need to be performed:</p>
<p>Add the external SDRAM to the linkerscript's <code>MEMORY</code> statements in the <code>project.xml</code> configuration:</p>
<div class="fragment"><div class="line">&lt;<span class="keywordtype">library</span>&gt;</div>
<div class="line">  &lt;<span class="keywordtype">collectors</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">collect</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;modm:platform:cortex-m:linkerscript.memory&quot;</span>&gt;</div>
<div class="line">       <span class="keyword">SDRAM</span> (<span class="keyword">rwx</span>) : <span class="keyword">ORIGIN</span> = 0<span class="keyword">xC0000000</span>, <span class="keyword">LENGTH</span> = 16<span class="keyword">M</span></div>
<div class="line">    &lt;/<span class="keywordtype">collect</span>&gt;</div>
<div class="line">  &lt;<span class="keywordtype">collectors</span>&gt;</div>
<div class="line">&lt;/<span class="keywordtype">library</span>&gt;</div>
</div><!-- end fragment -->
<p>You can also declare this as Python code in a lbuild <code>module.lb</code> file (useful for board support packages modules, see <a href="group__modm__board.html"><code>modm:board</code></a>):</p>
<div class="fragment"><div class="line">env.collect(&quot;:platform:cortex-m:linkerscript.memory&quot;,</div>
<div class="line">            &quot;SDRAM (rwx) : ORIGIN = 0xC0000000, LENGTH = 16M&quot;)</div>
</div><!-- end fragment -->
<p>Add a partition of the new memory to the linkerscripts <code>SECTION</code> statements. Since collectors order is only preserved locally, make sure to add the sections that depend on this order in <em>one value</em>. Here the previous value of the SDRAM location counter is required to "fill up" the remaining memory with the external heap section:</p>
<div class="fragment"><div class="line">linkerscript_sections = &quot;&quot;&quot;</div>
<div class="line">.data_sdram :</div>
<div class="line">{</div>
<div class="line">    __data_sdram_load = LOADADDR(.data_sdram);</div>
<div class="line">    __data_sdram_start = .;</div>
<div class="line"> </div>
<div class="line">    *(.data_sdram)</div>
<div class="line"> </div>
<div class="line">    . = ALIGN(4);</div>
<div class="line">    __data_sdram_end = .;</div>
<div class="line">} &gt;SDRAM AT &gt;FLASH</div>
<div class="line"> </div>
<div class="line">.heap_sdram (NOLOAD) :</div>
<div class="line">{</div>
<div class="line">    __heap_sdram_start = .;</div>
<div class="line">    . = ORIGIN(SDRAM) + LENGTH(SDRAM);</div>
<div class="line">    __heap_sdram_end = .;</div>
<div class="line">} &gt;SDRAM</div>
<div class="line">&quot;&quot;&quot;</div>
<div class="line">env.collect(&quot;:platform:cortex-m:linkerscript.sections&quot;, linkerscript_sections)</div>
</div><!-- end fragment -->
<p>Next, add the sections that need to be copied from ROM to RAM, here the contents of the <code>.data_sdram</code> section is stored in the internal <code>FLASH</code> memory and needs to be copied into SDRAM during the startup:</p>
<div class="fragment"><div class="line">linkerscript_copy = &quot;&quot;&quot;</div>
<div class="line">LONG(__data_sdram_load)</div>
<div class="line">LONG(__data_sdram_start)</div>
<div class="line">LONG(__data_sdram_end)</div>
<div class="line">&quot;&quot;&quot;</div>
<div class="line">env.collect(&quot;:platform:cortex-m:linkerscript.table_extern.copy&quot;, linkerscript_copy)</div>
</div><!-- end fragment -->
<p>And finally, to register the remaining memory in SDRAM with the allocator, add the memory range to the heap table. Remember to use the correct memory traits for this memory, see <code>modm:architecture:memory</code> for the trait definitions:</p>
<div class="fragment"><div class="line">linkerscript_heap = &quot;&quot;&quot;</div>
<div class="line">LONG(0x801f)</div>
<div class="line">LONG(__heap_sdram_start)</div>
<div class="line">LONG(__heap_sdram_end)</div>
<div class="line">&quot;&quot;&quot;</div>
<div class="line">env.collect(&quot;:platform:cortex-m:linkerscript.table_extern.heap&quot;, linkerscript_heap)</div>
</div><!-- end fragment -->
<dl class="section note"><dt>Note</dt><dd>Linkerscript collectors are plain text The collectors here only strip the leading/trailing whitespace and newlines and paste the result <em>as is</em> into the linkerscripts. No input validation is performed, so if you receive linker errors with your additions, please check the GNU LD documentation first.</dd></dl>
<h2>Blocking Delay</h2>
<p>The delay functions as defined by <a href="group__modm__architecture__delay.html"><code>modm:architecture:delay</code></a> are implemented via software loop (ARMv6-M devices) or hardware cycle counter (via <code>DWT-&gt;CYCCNT</code> on ARMv7-M device) and have the following limitations expressed in cycles, which depends on the configured CPU frequency:</p>
<ul>
<li>nanosecond delay is implemented as a tight loop with a minimum delay of &lt;20 cycles, a resolution of 1-4 cycles and a maximum delay of 32-bit cycles.</li>
<li>microsecond delay has a maximum delay of 32-bit cycles.</li>
</ul>
<h2>Compiler Options</h2>
<p>This module adds these architecture specific <a href="https://gcc.gnu.org/onlinedocs/gcc/Option-Summary.html">compiler options</a>:</p>
<ul>
<li><code>-mcpu=cortex-m{type}</code>: the target to compile for.</li>
<li><code>-mthumb</code>: only Thumb2 instruction set is supported.</li>
<li><code>-mfloat-abi={soft, softfp, hard}</code>: the FPU ABI: <code>hard</code> is fastest.</li>
<li><code>-mfpu=fpv{4, 5}-{sp}-d16</code>: single or double precision FPU.</li>
<li><code>-Wdouble-promotion</code>: if SP-FPU, warn if FPs are promoted to doubles. Note that unless you use the <code>.f</code> suffix or explicitly cast floating point operations to <code>float</code>, floating point constants are of <code>double</code> type, whose storage can result in an increased binary size. While you can add the <code>-fsingle-precision-constant</code> compiler flag to implicitly cast all doubles to floats, this also impacts compile time computations and may reduce accuracy. Therefore it is not enabled by default and you should carefully watch for any unwanted numeric side effects if you use this compiler option. See <a href="https://gcc.gnu.org/wiki/FloatingPointMath">Semantics of Floating Point Math in GCC</a>.</li>
</ul>
<p>In addition, these linker options are added:</p>
<ul>
<li><code>-nostartfiles</code>: modm implements its own startup script.</li>
<li><code>-wrap,_{calloc, malloc, realloc, free}_r</code>: reimplemented Newlib with our own allocator.</li>
</ul>
<h2>Module Options</h2>
<h3>modm:platform:cortex-m:main_stack_size: Minimum size of the application main stack</h3>
<p>The ARM Cortex-M uses a descending stack mechanism which is placed so that it grows towards the beginning of RAM. In case of a stack overflow the hardware then attempts to stack into invalid memory which triggers a HardFault. A stack overflow will therefore never overwrite any static or heap memory and this protection works without the MPU and therefore also on ARM Cortex-M0 devices.</p>
<p>If the vector table is relocated into RAM, the start address needs to be aligned to the next highest power-of-two word depending on the total number of device interrupts. On devices where the table is relocated into the same memory as the main stack, an alignment buffer up to 1kB is added to the main stack.</p>
<div class="fragment"><div class="line">|              ...                |</div>
<div class="line">|---------------------------------|</div>
<div class="line">|    Interrupt Vectors (in RAM)   |</div>
<div class="line">|        (<span class="keywordflow">if</span> re-mapped)           | &lt;-- vector table origin</div>
<div class="line">|---------------------------------| &lt;-- main stack top</div>
<div class="line">|           Main Stack            |</div>
<div class="line">|       (grows downwards)         |</div>
<div class="line">|               |                 |</div>
<div class="line">|               v                 |</div>
<div class="line">|---------------------------------|</div>
<div class="line">|  Alignment buffer <span class="keywordflow">for</span> vectors   |</div>
<div class="line">|   (overwritten by main stack!)  |</div>
<div class="line"><span class="stringliteral">&#39;---------------------------------&#39;</span> &lt;-- RAM origin</div>
</div><!-- end fragment -->
<p>Generated with: <code>3Ki (3072) in [256 .. 3Ki .. 64Ki]</code> </p><h3>modm:platform:cortex-m:float-abi: Floating point ABI</h3>
<p>Generated with: <code>hard in [hard, soft, softfp]</code> </p><h3>modm:platform:cortex-m:vector_table_location: Vector table location in ROM or RAM</h3>
<p>The vector table is always stored in ROM and copied to RAM by the startup script if required. You can modify the RAM vector table using the CMSIS NVIC functions:</p>
<ul>
<li><code>void NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)</code></li>
<li><code>uint32_t NVIC_GetVector(IRQn_Type IRQn)</code></li>
</ul>
<p>For applications that do not modify the vector table at runtime, relocation to RAM is not necessary and can save a few hundred bytes of static memory.</p>
<p>By default, the fastest option is chosen depending on the target memory architecture. This does not always mean the table is copied into RAM, and therefore may not be modifiable with this option!</p>
<p>From the ARM Cortex-M4 Technical Reference Manual on exception handling:</p>
<blockquote class="doxtable">
<p>&zwj;- Processor state is automatically stored to the stack on an exception, and automatically restored from the stack at the end of the Interrupt Service Routine.</p><ul>
<li>The vector is fetched in parallel to the state saving, enabling efficient interrupt entry. </li>
</ul>
</blockquote>
<dl class="section warning"><dt>Warning</dt><dd>On Interrupt Latency Placing main stack and vector table into the same memory can significantly slow down interrupt latency, since both I-Code and D-Code memory interface need to fetch from the same access port.</dd></dl>
<p>Generated with: <code>rom in [ram, rom]</code> </p><h3>modm:platform:cortex-m:linkerscript.flash_offset: Offset of FLASH Section Origin</h3>
<p>Add an offset to the default start address of the flash memory. This might be required for bootloaders located there.</p>
<dl class="section warning"><dt>Warning</dt><dd>Vector Table Relocation Not all offsets are compatible with the vector table relocation.</dd></dl>
<p>Generated with: <code>0 in [0 ... 0x100000]</code> </p><h3>modm:platform:cortex-m:linkerscript.flash_reserved: Add a reserved section at the end of the flash.</h3>
<p>Generated with: <code>0 in [0 ... 0x100000]</code> </p><h3>modm:platform:cortex-m:linkerscript.override: Path to project provided linkerscript</h3>
<p>Generated with: <code>[] in [Path]</code> </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga8db0a6548d7164c9124a8c5d74eaf474"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MODM_HARDWARE_INIT</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call <code>function</code> during boot process. </p>

</div>
</div>
<a class="anchor" id="ga59ce8a5b1d0b4b3ea222937c93a1caa5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MODM_HARDWARE_INIT_NAME</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call <code>function</code> during boot process with a unique name. </p>

</div>
</div>
<a class="anchor" id="ga59ce8a5b1d0b4b3ea222937c93a1caa5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MODM_HARDWARE_INIT_NAME</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call <code>function</code> during boot process with a unique name. </p>

</div>
</div>
<a class="anchor" id="ga5168e2a05059dd5a06987dfb15401f3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MODM_HARDWARE_INIT_NAME_ORDER</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call <code>function</code> during boot process in a global order with a unique name. </p>

</div>
</div>
<a class="anchor" id="ga5168e2a05059dd5a06987dfb15401f3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MODM_HARDWARE_INIT_NAME_ORDER</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call <code>function</code> during boot process in a global order with a unique name. </p>

</div>
</div>
<a class="anchor" id="ga609c75050044610ef690ed86a16a92d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MODM_HARDWARE_INIT_ORDER</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call <code>function</code> during boot process in a global order. </p>

</div>
</div>
<a class="anchor" id="ga609c75050044610ef690ed86a16a92d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MODM_HARDWARE_INIT_ORDER</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call <code>function</code> during boot process in a global order. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for DoxyPress 1.3.7-->
<!-- Generated by DoxyPress 1.7.0 -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.copperspice.com/documentation-doxypress.html">
    <img class="footer" src="doxypress.png" alt="DoxyPress"/></a> 1.7.0 </li>
  </ul>
</div>
<script>
if (window.location.href.includes("modm.io")) {
 var device = /\/api\/([a-zA-Z0-9_-]+)\//.exec(window.location.href)[1].toUpperCase();
 document.title = document.title.replace("modm API documentation", "modm API documentation for " + device);
 document.getElementById('projectname').innerHTML = document.getElementById('projectname').innerHTML.replace("modm API documentation", "modm API documentation for " + device);
}
document.getElementById('MSearchResults').onload = function()
{
  var iframe = document.getElementById('MSearchResults').contentWindow.document;
  var head = iframe.getElementsByTagName("head")[0];
  var link = iframe.createElement("link");
  link.setAttribute("rel", "stylesheet");
  link.setAttribute("type", "text/css");
  link.setAttribute("href", "../custom.css");
  head.appendChild(link);
  var link = iframe.createElement("link");
  link.setAttribute("rel", "stylesheet");
  link.setAttribute("type", "text/css");
  link.setAttribute("href", "../custom_dark_theme.css");
  head.appendChild(link);
}
</script>
</body>
</html>
