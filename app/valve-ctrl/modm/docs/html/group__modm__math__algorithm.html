<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="DoxyPress 1.7.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>modm API documentation: Algorithms</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxypress.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="custom_dark_theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by DoxyPress -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">modm API documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by DoxyPress 1.7.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__modm__math__algorithm.html',''); initResizable(); });
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
    <div class="title">Algorithms<div class="ingroups"><a class="el" href="group__modm__math.html">Math</a></div></div>
  </div>
  <div class="clear-floats"></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodm_1_1GenericPrescaler.html">modm::GenericPrescaler&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodm_1_1GenericPrescalerCounter.html">modm::GenericPrescalerCounter&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1b79c0c64edd5ba82d6ccedc05068b2b"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga1b79c0c64edd5ba82d6ccedc05068b2b"></a>
template&lt;typename T , typename TIter  = decltype(std::begin(std::declval&lt;T&gt;())), typename  = decltype(std::end(std::declval&lt;T&gt;()))&gt; </td></tr>
<tr class="memitem:ga1b79c0c64edd5ba82d6ccedc05068b2b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>modm::enumerate</b> (T &amp;&amp;iterable)</td></tr>
<tr class="separator:ga1b79c0c64edd5ba82d6ccedc05068b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4af42f8aa556958bee889c36d88d72d4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4af42f8aa556958bee889c36d88d72d4"><td class="memTemplItemLeft" align="right" valign="top">constexpr detail::Range&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__modm__math__algorithm.html#ga4af42f8aa556958bee889c36d88d72d4">modm::range</a> (const T &amp;stop)</td></tr>
<tr class="separator:ga4af42f8aa556958bee889c36d88d72d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab38515c93478201b19aa0acaa3c6795a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab38515c93478201b19aa0acaa3c6795a"><td class="memTemplItemLeft" align="right" valign="top">constexpr detail::Range&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__modm__math__algorithm.html#gab38515c93478201b19aa0acaa3c6795a">modm::range</a> (const T &amp;start, const T &amp;stop)</td></tr>
<tr class="separator:gab38515c93478201b19aa0acaa3c6795a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad26bf0759e8bc3154a7660161f95e2e8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad26bf0759e8bc3154a7660161f95e2e8"><td class="memTemplItemLeft" align="right" valign="top">constexpr detail::Range&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__modm__math__algorithm.html#gad26bf0759e8bc3154a7660161f95e2e8">modm::range</a> (const T &amp;start, const T &amp;stop, const T &amp;step)</td></tr>
<tr class="separator:gad26bf0759e8bc3154a7660161f95e2e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>lbuild module: <code>modm:math:algorithm</code></p>
<p>A collection of useful and lightweight algorithms.</p>
<h2>Convenience Iterators</h2>
<p>Inspired by Python's built-in <code>range</code> and <code>enumerate</code> functions, you can use <code>modm::range</code> and <code>modm::enumerate</code> in for loops:</p>
<div class="fragment"><div class="line"><span class="comment">// Iterates over 0 .. 9</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> i : <a class="code" href="group__modm__math__algorithm.html#gad26bf0759e8bc3154a7660161f95e2e8">modm::range</a>(10)) {</div>
<div class="line">    <a class="code" href="group__modm__debug.html#gaa818d31e0c2792328f81da25f256b79e">MODM_LOG_INFO</a> &lt;&lt; i &lt;&lt; <a class="code" href="group__modm__io.html#ga25d1ec416bcd6a8b8d1d280c99fd2d55">modm::endl</a>;</div>
<div class="line">}</div>
<div class="line"><span class="comment">// Iterates over 10 .. 19</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> i : <a class="code" href="group__modm__math__algorithm.html#gad26bf0759e8bc3154a7660161f95e2e8">modm::range</a>(10, 20)) {</div>
<div class="line">    <a class="code" href="group__modm__debug.html#gaa818d31e0c2792328f81da25f256b79e">MODM_LOG_INFO</a> &lt;&lt; i &lt;&lt; <a class="code" href="group__modm__io.html#ga25d1ec416bcd6a8b8d1d280c99fd2d55">modm::endl</a>;</div>
<div class="line">}</div>
<div class="line"><span class="comment">// Iterates over 20, 22, 24, 26, 28</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> i : <a class="code" href="group__modm__math__algorithm.html#gad26bf0759e8bc3154a7660161f95e2e8">modm::range</a>(20, 30, 2)) {</div>
<div class="line">    <a class="code" href="group__modm__debug.html#gaa818d31e0c2792328f81da25f256b79e">MODM_LOG_INFO</a> &lt;&lt; i &lt;&lt; <a class="code" href="group__modm__io.html#ga25d1ec416bcd6a8b8d1d280c99fd2d55">modm::endl</a>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Iterates over 0 .. N-1, where N = size of iterable</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> [i, item] : modm::enumerate(iterable)) {</div>
<div class="line">    <a class="code" href="group__modm__debug.html#gaa818d31e0c2792328f81da25f256b79e">MODM_LOG_INFO</a> &lt;&lt; i &lt;&lt; item &lt;&lt; <a class="code" href="group__modm__io.html#ga25d1ec416bcd6a8b8d1d280c99fd2d55">modm::endl</a>;</div>
<div class="line">}</div>
</div><!-- end fragment -->
<h2>Prescaler Calculators</h2>
<p>Peripheral output frequencies are usually generated by dividing an input clock with a prescaler in hardware. Finding the closest prescaler value for a desired output frequency can be unintuitive, therefore, these classes provide a simple interface for a constexpr calculator.</p>
<p>All calculators return a <code>Result</code> struct containing desired, input, and output frequencies, the relative error of the output vs desired frequency, and the prescaler and its index. The prescaler index is typically the value to write to the register directly:</p>
<div class="fragment"><div class="line"><span class="comment">// 16-bit linear prescaler [1, 2^16] mapped as [0, 0xffff].</span></div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> result = Prescaler::from_linear(10_MHz, 1_kHz, 1, 1ul &lt;&lt; 16);</div>
<div class="line"><span class="keyword">static_assert</span>(result.input_frequency == 10_MHz);</div>
<div class="line"><span class="keyword">static_assert</span>(result.desired_frequency == 1_kHz);</div>
<div class="line"><span class="comment">// Calculator finds an exact match without error</span></div>
<div class="line"><span class="keyword">static_assert</span>(result.frequency == 1_kHz);</div>
<div class="line"><span class="keyword">static_assert</span>(result.error == 0);</div>
<div class="line"><span class="comment">// with prescaler 1e4 = 1e7 / 1e3.</span></div>
<div class="line"><span class="keyword">static_assert</span>(result.prescaler == 10<span class="stringliteral">&#39;000);</span></div>
<div class="line"><span class="stringliteral">static_assert(result.index == 9&#39;</span>999);</div>
<div class="line">PERIPHERAL-&gt;PRESCALER = result.index;</div>
</div><!-- end fragment -->
<p>The index is particularly useful for non-contiguous prescalers, the most common being power-of-two values:</p>
<div class="fragment"><div class="line"><span class="comment">// Power-of-two prescaler with 8 values between [16, 4096].</span></div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> result = Prescaler::from_power(32_kHz, 100_Hz, 1ul &lt;&lt; 4, 1ul &lt;&lt; 12);</div>
<div class="line"><span class="comment">// Calculator cannot find an exact match! Closest has -25% error!</span></div>
<div class="line"><span class="keyword">static_assert</span>(result.frequency == 125_Hz);</div>
<div class="line"><span class="keyword">static_assert</span>(result.error == -0.25);</div>
<div class="line"><span class="comment">// Ideal Prescaler is 320, clostest is 256</span></div>
<div class="line"><span class="keyword">static_assert</span>(result.prescaler == 256);</div>
<div class="line"><span class="comment">// Index is 256 = 1ul &lt;&lt; (4 + 4)</span></div>
<div class="line"><span class="keyword">static_assert</span>(result.index == 4);</div>
</div><!-- end fragment -->
<p>Non-contiguous prescalers can also be created with a modifier function:</p>
<div class="fragment"><div class="line"><span class="comment">// Only even prescalers from [2, 1024]</span></div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> result = Prescaler::from_function(</div>
<div class="line">        110_MHz, 3.5_MHz, 1, 512, [](uint32_t i){ <span class="keywordflow">return</span> i*2; });</div>
<div class="line"><span class="comment">// Ideal prescaler is 31.4, closest is 32 with ~2% error.</span></div>
<div class="line"><span class="keyword">static_assert</span>(result.frequency == 3.4375_MHz);</div>
<div class="line"><span class="keyword">static_assert</span>(result.error == 0.02);</div>
<div class="line"><span class="keyword">static_assert</span>(result.prescaler == 32);</div>
<div class="line"><span class="keyword">static_assert</span>(result.index == 15); <span class="comment">// 32/2 - 1</span></div>
</div><!-- end fragment -->
<p>For all other cases, prescalers can be passed as an initializer list or as any forward range. Note that the prescaler values <em>must</em> be sorted, otherwise the calculator will compute the wrong prescaler values!</p>
<div class="fragment"><div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> result = Prescaler::from_list(1_MHz, 1_kHz, {2,4,16,256,1024});</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> result = Prescaler::from_range(2_kHz, 1_kHz, std::array{1,2,3});</div>
</div><!-- end fragment -->
<p>A special case is made of two chained prescalers that are both linear powers-of-two. These are often called "fractional prescalers" and act as a single binary-scaled linear prescaler and can thus be modeled as such:</p>
<div class="fragment"><div class="line"><span class="comment">// A fractional 12.4-bit prescaler can be modeled as a single 16-bit prescaler.</span></div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> result = Prescaler::from_linear(SystemClock::Usart1, 115200, 16, 1ul &lt;&lt; 16);</div>
<div class="line"><span class="comment">// The resulting prescaler can be written directly to the register.</span></div>
<div class="line">USART1-&gt;BRR = result.prescaler;</div>
</div><!-- end fragment -->
<h3>Prescalers with Counters</h3>
<p>However, often chained prescalers cannot be converted to a linear prescaler, for example, a timer with a set of power-of-two prescalers and a 16 or 32-bit counter. These must be computed with a different class:</p>
<div class="fragment"><div class="line"><span class="comment">// A prescaler with power-of-two values [4, 256] going into a 12-bit down counter.</span></div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> result = PrescalerCounter::from_power(32_kHz, 1_Hz, 1ul &lt;&lt; 12, 4, 256);</div>
<div class="line"><span class="comment">// Calculator finds an exact match without error</span></div>
<div class="line"><span class="keyword">static_assert</span>(result.frequency == 1_Hz);</div>
<div class="line"><span class="keyword">static_assert</span>(result.error == 0);</div>
<div class="line"><span class="comment">// with prescaler 8 and counter 4&#39;000.</span></div>
<div class="line"><span class="keyword">static_assert</span>(result.prescaler == 8);</div>
<div class="line"><span class="keyword">static_assert</span>(result.counter == 4<span class="stringliteral">&#39;000);</span></div>
<div class="line"><span class="stringliteral">static_assert(result.index == 1);</span></div>
</div><!-- end fragment -->
<p>The calculator only picks the first prescaler with the lowest error, however, in this example, there can be multiple exact solutions:</p>
<p>32000 = 8 × 4000 = 16 × 2000 = ... = 128 × 250 = 256 × 125</p>
<p>If the prescaler and counter is used to generate a waveform like PWM, then it is beneficial to pick the combination with the largest counter value. However, if the use case is to preserve power, then a slow running counter requires the highest prescaler. Therefore the order of prescalers can be reversed:</p>
<div class="fragment"><div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> result = PrescalerCounter::from_power(32_kHz, 1_Hz, 1ul &lt;&lt; 12, 256, 4);</div>
<div class="line"><span class="keyword">static_assert</span>(result.prescaler == 256);</div>
<div class="line"><span class="keyword">static_assert</span>(result.counter == 125);</div>
<div class="line"><span class="comment">// Index is not the same!</span></div>
<div class="line"><span class="keyword">static_assert</span>(result.index == 0);</div>
</div><!-- end fragment -->
<p>The same applies to the <code>PrescalerCounter::from_linear()</code> and <code>PrescalerCounter::from_function()</code> calculators, while the order for lists and forward ranges can be entirely arbitrary:</p>
<div class="fragment"><div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> result = PrescalerCounter::from_list(32_kHz, 1_Hz, 1ul &lt;&lt; 12, {128,16,256,4});</div>
<div class="line"><span class="keyword">static_assert</span>(result.prescaler == 128);</div>
<div class="line"><span class="keyword">static_assert</span>(result.counter == 250);</div>
<div class="line"><span class="comment">// Index is relative to the list order now!</span></div>
<div class="line"><span class="keyword">static_assert</span>(result.index == 0);</div>
</div><!-- end fragment -->
<dl class="section note"><dt>Note</dt><dd>Time Durations While the calculator is designed for frequencies, time durations can also be computed by transforming the input as <code>frequency = 1.0 / duration</code> and then transforming the output back as <code>duration = 1.0 / frequency</code>.</dd></dl>
<p>Floating-Point Frequencies You can define the type used for frequency representation by using the <code>GenericPrescaler&lt;double&gt;</code> and <code>GenericPrescalerCounter&lt;double&gt;</code> classes.</p>
<h3>Tolerance of Prescaler Error</h3>
<p>Each <code>Result</code> has a signed(!), relative error attached, which can be used to assert on the quality of the calculation. Note that using <code>static_assert</code> on the error directly will only print the error values:</p>
<div class="fragment"><div class="line"><span class="keyword">static_assert</span>(std::abs(result.error) &lt; 5_pct);</div>
</div><!-- end fragment -->
 <div class="fragment"><div class="line">error: <span class="keyword">static</span> assertion failed</div>
<div class="line"> | <span class="keyword">static_assert</span>(std::abs(result.error) &lt; tolerance);</div>
<div class="line"> |               ~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~</div>
<div class="line">note: the comparison reduces to <span class="stringliteral">&#39;(0.10 &lt; 0.05)&#39;</span></div>
</div><!-- end fragment -->
<p>However, by using a helper method, the requested and closest available frequencies can be displayed to the developer:</p>
<div class="fragment"><div class="line"><span class="comment">// Accidentally used kBaud instead of Baud, which cannot be generated</span></div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> result = Prescaler::from_linear(SystemClock::Usart2, 115200_kBd, 16, 1ul &lt;&lt; 16);</div>
<div class="line">modm::assertBaudrateInTolerance&lt;result.frequency, result.desired_frequency, tolerance&gt;();</div>
</div><!-- end fragment -->
 <div class="fragment"><div class="line">In instantiation of <span class="stringliteral">&#39;static void modm::PeripheralDriver::assertBaudrateInTolerance()</span></div>
<div class="line"><span class="stringliteral">[with long long unsigned int available = 3000000; long long unsigned int requested = 115200000; float tolerance = 0.01f]&#39;</span>:</div>
<div class="line">error: <span class="keyword">static</span> assertion failed: The closest available baudrate exceeds the tolerance of the requested baudrate!</div>
<div class="line"> | <span class="keyword">static_assert</span>(modm::isValueInTolerance(requested, available, tolerance),</div>
<div class="line"> |               ~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div>
<div class="line">note: <span class="stringliteral">&#39;modm::isValueInTolerance&lt;long long unsigned int&gt;(115200000, 3000000, 0.01f)&#39;</span> evaluates to <span class="keyword">false</span></div>
</div><!-- end fragment -->
 <h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gab38515c93478201b19aa0acaa3c6795a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr detail::Range&lt;T&gt; modm::range </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an iterable range [start, stop) of step 1. </p><dl class="section warning"><dt>Warning</dt><dd>Returns an empty range if start &gt;= stop! </dd></dl>

</div>
</div>
<a class="anchor" id="gad26bf0759e8bc3154a7660161f95e2e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr detail::Range&lt;T&gt; modm::range </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>stop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an iterable range [start, stop) of step != 0. </p><dl class="section warning"><dt>Warning</dt><dd>Returns an empty range if (start &gt;= stop and step &gt;= 0) or (start &lt;= stop and step &lt;= 0)! </dd></dl>

</div>
</div>
<a class="anchor" id="ga4af42f8aa556958bee889c36d88d72d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr detail::Range&lt;T&gt; modm::range </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>stop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an iterable range [0, stop) of step 1. </p><dl class="section warning"><dt>Warning</dt><dd>Returns an empty range if stop &lt;= 0! </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for DoxyPress 1.3.7-->
<!-- Generated by DoxyPress 1.7.0 -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.copperspice.com/documentation-doxypress.html">
    <img class="footer" src="doxypress.png" alt="DoxyPress"/></a> 1.7.0 </li>
  </ul>
</div>
<script>
if (window.location.href.includes("modm.io")) {
 var device = /\/api\/([a-zA-Z0-9_-]+)\//.exec(window.location.href)[1].toUpperCase();
 document.title = document.title.replace("modm API documentation", "modm API documentation for " + device);
 document.getElementById('projectname').innerHTML = document.getElementById('projectname').innerHTML.replace("modm API documentation", "modm API documentation for " + device);
}
document.getElementById('MSearchResults').onload = function()
{
  var iframe = document.getElementById('MSearchResults').contentWindow.document;
  var head = iframe.getElementsByTagName("head")[0];
  var link = iframe.createElement("link");
  link.setAttribute("rel", "stylesheet");
  link.setAttribute("type", "text/css");
  link.setAttribute("href", "../custom.css");
  head.appendChild(link);
  var link = iframe.createElement("link");
  link.setAttribute("rel", "stylesheet");
  link.setAttribute("type", "text/css");
  link.setAttribute("href", "../custom_dark_theme.css");
  head.appendChild(link);
}
</script>
</body>
</html>
