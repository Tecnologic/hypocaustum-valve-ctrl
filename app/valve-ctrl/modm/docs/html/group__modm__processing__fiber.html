<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="DoxyPress 1.7.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>modm API documentation: Fibers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxypress.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="custom_dark_theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by DoxyPress -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">modm API documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by DoxyPress 1.7.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__modm__processing__fiber.html',''); initResizable(); });
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enums</a>  </div>
  <div class="headertitle">
    <div class="title">Fibers<div class="ingroups"><a class="el" href="group__modm__processing.html">Processing</a></div></div>
  </div>
  <div class="clear-floats"></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__modm__processing__fiber__context"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__processing__fiber__context.html">Fiber Context Functions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodm_1_1Fiber.html">modm::Fiber&lt; StackSize &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodm_1_1fiber_1_1Scheduler.html">modm::fiber::Scheduler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodm_1_1fiber_1_1Task.html">modm::fiber::Task</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodm_1_1fiber_1_1barrier.html">modm::fiber::barrier&lt; CompletionFunction &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodm_1_1fiber_1_1counting__semaphore.html">modm::fiber::counting_semaphore&lt; LeastMaxValue &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodm_1_1fiber_1_1latch.html">modm::fiber::latch</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodm_1_1fiber_1_1mutex.html">modm::fiber::mutex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodm_1_1fiber_1_1shared__mutex.html">modm::fiber::shared_mutex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enums</h2></td></tr>
<tr class="memitem:gadeb568e66bd8d41913224531f3f3300c"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__processing__fiber.html#gadeb568e66bd8d41913224531f3f3300c">modm::Fiber&lt; StackSize &gt;::Start</a> </td></tr>
<tr class="separator:gadeb568e66bd8d41913224531f3f3300c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9642d9a15dcd84c06a9c4312f4bf442"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae9642d9a15dcd84c06a9c4312f4bf442"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>cv_status</b> </td></tr>
<tr class="separator:gae9642d9a15dcd84c06a9c4312f4bf442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5ff44afffaeb083e8dc505973fb7ce7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab5ff44afffaeb083e8dc505973fb7ce7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__processing__fiber.html#gab5ff44afffaeb083e8dc505973fb7ce7">modm::Fiber&lt; StackSize &gt;::condition_variable</a> = condition_variable_any</td></tr>
<tr class="memdesc:gab5ff44afffaeb083e8dc505973fb7ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">There is no specialization for <code>std::unique_lock&lt;<a class="el" href="classmodm_1_1fiber_1_1mutex.html">fiber::mutex</a>&gt;</code>. <br /></td></tr>
<tr class="separator:gab5ff44afffaeb083e8dc505973fb7ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c056aeddd8e0ad505404f852143f244"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6c056aeddd8e0ad505404f852143f244"></a>
static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__processing__fiber.html#ga6c056aeddd8e0ad505404f852143f244">modm::Fiber&lt; StackSize &gt;::StackAlignment</a> = sizeof(uintptr_t) * 2</td></tr>
<tr class="memdesc:ga6c056aeddd8e0ad505404f852143f244"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alignment requirements for the bottom and top of the stack. <br /></td></tr>
<tr class="separator:ga6c056aeddd8e0ad505404f852143f244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad693c9172a91dfa309533bf062041b1f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad693c9172a91dfa309533bf062041b1f"></a>
static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__processing__fiber.html#gad693c9172a91dfa309533bf062041b1f">modm::Fiber&lt; StackSize &gt;::StackSizeMinimum</a> = 108</td></tr>
<tr class="memdesc:gad693c9172a91dfa309533bf062041b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum stack size required to push one full fiber context. <br /></td></tr>
<tr class="separator:gad693c9172a91dfa309533bf062041b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ec71abb103b2967a7afb10fdb081b93"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__processing__fiber.html#ga7ec71abb103b2967a7afb10fdb081b93">modm::Fiber&lt; StackSize &gt;::StackSizeDefault</a> = 1024</td></tr>
<tr class="separator:ga7ec71abb103b2967a7afb10fdb081b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>lbuild module: <code>modm:processing:fiber</code></p>
<p>This module provides a lightweight stackful fiber implementation including a simple round-robin scheduler. Here is a minimal example that blinks an LED:</p>
<div class="fragment"><div class="line"><a class="code" href="classmodm_1_1Fiber.html">modm::Fiber&lt;&gt;</a> fiber([]</div>
<div class="line">{</div>
<div class="line">    Board::LedBlue::setOutput();</div>
<div class="line">    <span class="keywordflow">while</span>(<span class="keyword">true</span>)</div>
<div class="line">    {</div>
<div class="line">        Board::LedBlue::toggle();</div>
<div class="line">        <a class="code" href="group__modm__architecture__fiber.html#ga54cfe0c7cf7a5d1cb2dfe13f61d33de2">modm::this_fiber::sleep_for</a>(1s);</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classmodm_1_1fiber_1_1Scheduler.html#a99d4d5f5e7c294607a49023685b2ce65">modm::fiber::Scheduler::run</a>();</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- end fragment -->
<h2>Construction</h2>
<p>You can construct a fiber from any function without return type or arguments:</p>
<div class="fragment"><div class="line"><a class="code" href="classmodm_1_1Fiber.html">modm::Fiber&lt;&gt;</a> fiber([]{});</div>
<div class="line"><span class="keywordtype">void</span> function() {}</div>
<div class="line"><a class="code" href="classmodm_1_1Fiber.html">modm::Fiber&lt;&gt;</a> fiber2(function);</div>
</div><!-- end fragment -->
<p>To call objects with arguments, wrap the data into a lambda closure and pass it to fiber. The closure will be constructed at the top of the stack and allows the lambda wrapper to call your function with an argument:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>DataObject</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">void</span> member_function(<span class="keywordtype">int</span> arg);</div>
<div class="line">} object;</div>
<div class="line"><span class="keywordtype">int</span> number{42};</div>
<div class="line"><a class="code" href="classmodm_1_1Fiber.html">modm::Fiber&lt;&gt;</a> fiber([&amp;]</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">object</span>.member_function(number);</div>
<div class="line">});</div>
</div><!-- end fragment -->
<p>Remember to use the right capture method for the lifetime of the objects you want to call. You can <code>std::move()</code> already constructed objects into the capture, or construct them in the capture directly, if they would get destroyed after fiber construction. You may need to mark the lambda mutable:</p>
<div class="fragment"><div class="line"><a class="code" href="classmodm_1_1Fiber.html">modm::Fiber&lt;&gt;</a> fiber2([obj=std::move(<span class="keywordtype">object</span>), obj2=DataObject()] <span class="keyword">mutable</span></div>
<div class="line">{</div>
<div class="line">    obj.member_function(24);</div>
<div class="line">    obj2.member_function(42);</div>
<div class="line">});</div>
</div><!-- end fragment -->
<dl class="section warning"><dt>Warning</dt><dd>Do not construct <code><a class="el" href="classmodm_1_1Fiber.html">modm::Fiber</a></code> on the stack! Apart from the general lifetime issues of constructing objects on the stack, the allocated fiber stack size is likely too large for the caller stack and will lead to a stack overflow.</dd></dl>
<p>A fiber can be passed a <code><a class="el" href="classmodm_1_1fiber_1_1stop__token.html">modm::fiber::stop_token</a></code> to allow the fiber to be stopped cooperatively.</p>
<div class="fragment"><div class="line"><a class="code" href="classmodm_1_1Fiber.html">modm::Fiber&lt;&gt;</a> fiber([](<a class="code" href="classmodm_1_1fiber_1_1stop__token.html">modm::fiber::stop_token</a> stoken)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// set up</span></div>
<div class="line">    <span class="keywordflow">while</span>(not stoken.stop_requested())</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// run your task</span></div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// clean up</span></div>
<div class="line">});</div>
<div class="line"><span class="comment">// externally request the fiber to stop</span></div>
<div class="line">fiber.<a class="code" href="classmodm_1_1fiber_1_1Task.html#aa76b8e5462e175143cc4f7e1224b4884">request_stop</a>();</div>
<div class="line"><span class="comment">// wait until fiber has stopped</span></div>
<div class="line">fiber.join();</div>
</div><!-- end fragment -->
<p>Note that the fiber destructor requests to stop and joins automatically. The interface and behavior is similar to the C++20 <code>std::jthread</code>.</p>
<h2>Delayed Start</h2>
<p>Fiber are added to the scheduler automatically and start execution when the scheduler is run. You can disable this behavior by setting <code>start</code> to <code>modm::fiber::Start::Later</code> during construction and manually starting the fiber when it is ready, also from another fiber:</p>
<div class="fragment"><div class="line"><span class="comment">// fiber does not automatically start executing</span></div>
<div class="line"><a class="code" href="classmodm_1_1Fiber.html">modm::Fiber&lt;&gt;</a> fiber2(function, modm::fiber::Start::Later);</div>
<div class="line"><span class="comment">// fiber2 is automatically executing</span></div>
<div class="line"><a class="code" href="classmodm_1_1Fiber.html">modm::Fiber&lt;&gt;</a> fiber1([&amp;]</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="group__modm__architecture__fiber.html#ga54cfe0c7cf7a5d1cb2dfe13f61d33de2">modm::this_fiber::sleep_for</a>(1s);</div>
<div class="line">    fiber2.start();</div>
<div class="line">});</div>
<div class="line"><a class="code" href="classmodm_1_1fiber_1_1Scheduler.html#a99d4d5f5e7c294607a49023685b2ce65">modm::fiber::Scheduler::run</a>();</div>
<div class="line"><span class="comment">// fiber1 waits 1s, then starts fiber2 and exits</span></div>
</div><!-- end fragment -->
<p>Fibers can end by returning from their wrapper, after which they will be removed from the scheduler. A fiber can then be restarted again by calling <code>start()</code>, which will call the closure again from the beginning. Note, that the lambda capture is not destructed and reconstructed, but remains unchanged between restarts. If you need a fiber that is only callable once, you can implement this behavior manually with a boolean in the capture:</p>
<div class="fragment"><div class="line"><a class="code" href="classmodm_1_1Fiber.html">modm::Fiber&lt;&gt;</a> fiber([ran=<span class="keyword">false</span>]</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (ran) <span class="keywordflow">return</span>;</div>
<div class="line">    ran = <span class="keyword">true</span>;</div>
<div class="line">    <span class="comment">// only called once.</span></div>
<div class="line">});</div>
</div><!-- end fragment -->
<h2>Customization</h2>
<p>The most important customization is the fiber stack size expressed in bytes:</p>
<div class="fragment"><div class="line"><a class="code" href="classmodm_1_1Fiber.html">modm::Fiber&lt;128&gt;</a> fiber1(...);</div>
<div class="line"><a class="code" href="classmodm_1_1Fiber.html">modm::Fiber&lt;256&gt;</a> fiber2(...);</div>
</div><!-- end fragment -->
<p>The <code>Fiber</code> class is intentionally constructed at runtime, so that it does not increase your program size, as the <code>.data</code> section would. You may also place the fibers into the <code>.faststack</code> section, which is not zeroed and thus saves a bit of time on startup:</p>
<div class="fragment"><div class="line"><a class="code" href="group__modm__architecture.html#ga187fdfaf619fb6e65a878b8ed4b6fbc3">modm_faststack</a> <a class="code" href="classmodm_1_1Fiber.html">modm::Fiber&lt;&gt;</a>(stack, function);</div>
</div><!-- end fragment -->
<p>However, it may be desirable to control the placement of the fiber task structure and especially the stack, depending on the types of memories available on your device. This is possible when you construct the stack and task in combination with the <code><a class="el" href="group__modm__architecture.html#ga1f31943d7806c1bd0a4ccb49399a4a81" title="Specifies that a variable (or function) lives in a particular section. ">modm_section()</a></code> macros and its specializations:</p>
<div class="fragment"><div class="line"><span class="comment">// Place a very large stack in the external memory</span></div>
<div class="line"><a class="code" href="group__modm__architecture.html#ga1f31943d7806c1bd0a4ccb49399a4a81">modm_section</a>(<span class="stringliteral">&quot;.sdram_noinit&quot;</span>) modm::fiber::Stack&lt;1024*10&gt; large_stack;</div>
<div class="line"><span class="comment">// But keep the task control structure in internal memory</span></div>
<div class="line"><a class="code" href="group__modm__architecture.html#ga1fc08f57913d51e62a02cf38b47a2f86">modm_fastdata</a> modm::fiber::Task fiber(large_stack, big_function);</div>
</div><!-- end fragment -->
<h3>Subclassing</h3>
<p>You can inherit from the <code><a class="el" href="classmodm_1_1Fiber.html">modm::Fiber</a></code> class to extend a fiber with a proper object interface. This is useful for providing a more expressive interface to a fiber by means of shared memory.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>CustomFiber : <span class="keyword">public</span> <a class="code" href="classmodm_1_1Fiber.html">modm::Fiber</a>&lt;&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    CustomFiber() : Fiber([this]{ run(); }) {}</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// called from another fiber</span></div>
<div class="line">    <span class="keywordtype">void</span> trigger() { trigger_ = <span class="keyword">true</span>; }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">bool</span> trigger_{<span class="keyword">false</span>}; <span class="comment">// shared memory between fibers</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> <span class="keyword">inline</span></div>
<div class="line">    run()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">while</span>(<span class="keyword">true</span>)</div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="group__modm__architecture__fiber.html#ga7fe85ec7252e960077434806cbe24e21">modm::this_fiber::poll</a>([&amp;]{ <span class="keywordflow">return</span> trigger_; });</div>
<div class="line">            trigger_ = <span class="keyword">false</span>;</div>
<div class="line">            <span class="comment">// long running response to the trigger</span></div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- end fragment -->
<h2>Concurrency Support</h2>
<p>The <code><a class="el" href="classmodm_1_1Fiber.html">modm::fiber</a></code> namespace provides several standard concurrency primitives to synchronize fibers based on the <a href="https://en.cppreference.com/w/cpp/thread"><code>std::thread</code> interface behavior</a>. Most primitives are implemented on top of <code>&lt;atomic&gt;</code>, therefore can be called from within (nested) interrupts. The API docs explicitly mention if a function is safe to call from an interrupt.</p>
<h3>Threads</h3>
<ul>
<li><code>Task</code> implements most of the <code>std::jthread</code> interface.</li>
</ul>
<p>In particular, <code>Task</code> only implements functionality that does not require dynamic memory allocations. The stack memory needs to be allocated externally and fibers are not movable or copyable and therefore cannot be detached or swapped.</p>
<h3>Thread Cancellation</h3>
<ul>
<li><code>stop_token</code> and <code>stop_source</code> with simplified implementations.</li>
<li><code>stop_callback</code> <b>not implemented</b>.</li>
</ul>
<p>To avoid dynamic memory allocations, a <code>stop_state</code> object provides the actual memory required for the limited functionality:</p>
<div class="fragment"><div class="line"><a class="code" href="classmodm_1_1fiber_1_1stop__state.html">modm::fiber::stop_state</a> state;</div>
<div class="line"><span class="comment">// only valid as long as state is valid!</span></div>
<div class="line"><span class="keyword">auto</span> source = state.get_source();</div>
<div class="line"><span class="keyword">auto</span> token = state.get_token();</div>
<div class="line"><span class="comment">// use token in a condition variable</span></div>
<div class="line">cv.wait(lock, token, predicate);</div>
<div class="line"><span class="comment">// request a stop somewhere else</span></div>
<div class="line">source.request_stop();</div>
</div><!-- end fragment -->
<p>Implemented using interrupt-safe atomics.</p>
<h3>Mutual Exclusion</h3>
<ul>
<li><code>mutex</code> and <code>timed_mutex</code>.</li>
<li><code>recursive_mutex</code> and <code>recursive_timed_mutex</code>.</li>
<li><code>shared_mutex</code> and <code>shared_timed_mutex</code>.</li>
</ul>
<p>Implemented using interrupt-safe atomics.</p>
<h4>Generic Mutex Management</h4>
<ul>
<li><code>lock_guard</code>, <code>scoped_lock</code>, <code>unique_lock</code> and <code>shared_lock</code>.</li>
<li><code>defer_lock_t</code>, <code>try_to_lock_t</code> and <code>adopt_lock_t</code>.</li>
<li><code>defer_lock</code>, <code>try_to_lock</code> and <code>adopt_lock</code>.</li>
</ul>
<h4>Generic Locking Algorithms</h4>
<ul>
<li><code>try_lock</code> and <code>lock</code>.</li>
</ul>
<h4>Call Once</h4>
<ul>
<li><code>once_flag</code> and <code>call_once</code>.</li>
</ul>
<p>Implemented using interrupt-safe atomic flag.</p>
<h3>Condition Variables</h3>
<ul>
<li><code>condition_variable</code> and <code>condition_variable_any</code>.</li>
<li><code>cv_status</code>.</li>
<li><code>notify_all_at_thread_exit</code> <b>not implemented</b>.</li>
</ul>
<p>Notification is implemented as a interrupt-safe 16-bit atomic counter.</p>
<h3>Semaphores</h3>
<ul>
<li><code>counting_semaphore</code> and <code>binary_semaphore</code>.</li>
</ul>
<p>Counts are implemented as interrupt-safe 16-bits atomics.</p>
<h3>Latches and Barriers</h3>
<ul>
<li><code>latch</code>: implemented as interrupt-safe atomics.</li>
<li><code>barrier</code>: <b>not</b> interrupt-safe!</li>
</ul>
<p>Counts are implemented as 16-bits.</p>
<h2>Stack Usage</h2>
<p>To measure the stack usage of a fiber, you need to explicitly watermark the stack <em>before</em> running the fiber, then you may query the stack usage inside or outside the fiber:</p>
<div class="fragment"><div class="line"><span class="comment">// You must watermark the stack *before* running the fiber!</span></div>
<div class="line">fiber1.stack_watermark();</div>
<div class="line"><span class="comment">// now you can run the fibers via the scheduler</span></div>
<div class="line"><a class="code" href="classmodm_1_1fiber_1_1Scheduler.html#a99d4d5f5e7c294607a49023685b2ce65">modm::fiber::Scheduler::run</a>();</div>
<div class="line"><span class="comment">// can be called from inside or outside the fiber, before or after running!</span></div>
<div class="line"><span class="keywordtype">size_t</span> bytes = fiber.stack_usage();</div>
</div><!-- end fragment -->
<p>Note that stack usage measurement through watermarking can be inaccurate if the registers contain the watermark value.</p>
<h2>Stack Overflow</h2>
<p>Each context switch checks if the stack overflowed, in which case the scheduler will abandon execution and trigger an assertion on the main stack with the identifier <code>fbr.stkof</code> and the fiber pointer as context. Note that the assertion is executed on the main stack and not on the fiber stack that overflowed!</p>
<p>On ARMv8-M devices, the stack overflow is checked in hardware via the PSPLIM register, therefore the context switch is a little faster.</p>
<h2>Scheduling</h2>
<p>The scheduler <code>run()</code> function will suspend execution of the call site, usually the main function, start each fiber and continue to execute them until they all ended and then return execution to the call site:</p>
<div class="fragment"><div class="line"><span class="keywordflow">while</span>(<span class="keyword">true</span>)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classmodm_1_1fiber_1_1Scheduler.html#a99d4d5f5e7c294607a49023685b2ce65">modm::fiber::Scheduler::run</a>();</div>
<div class="line">    <span class="comment">// sleep until the next interrupt?</span></div>
<div class="line">    __WFI();</div>
<div class="line">    <span class="comment">// then start the fibers again</span></div>
<div class="line">    fiber.start();</div>
<div class="line">}</div>
</div><!-- end fragment -->
<p>Please note that neither the fiber nor scheduler is interrupt safe, so starting threads from interrupt context is a bad idea!</p>
<dl class="section note"><dt>Note</dt><dd>Using <code><a class="el" href="group__modm__architecture__fiber.html#gadaca0b8f126b33ceb0f470a56cc410cb">yield()</a></code> outside of a fiber If <code><a class="el" href="group__modm__architecture__fiber.html#gadaca0b8f126b33ceb0f470a56cc410cb">yield()</a></code> is called before the scheduler started or if only one fiber is running, it simply returns in-place, since there is nowhere to switch to.</dd></dl>
<h2>Platforms</h2>
<p>Fibers are implemented by saving callee registers to the current stack, then switching to a new stack and restoring callee registers from this stack. The static <code><a class="el" href="group__modm__architecture__fiber.html#gadaca0b8f126b33ceb0f470a56cc410cb">modm::this_fiber::yield()</a></code> function wraps this functionality in a transparent way.</p>
<h3>AVR</h3>
<p>On AVRs the fiber stack is shared with the currently active interrupt. This requires the fiber stack size to include the worst case stack size of all interrupts. Fortunately on AVRs interrupts cannot be nested.</p>
<p>Therefore the default stack size is a fairly large <b>512B</b>.</p>
<h3>Arm Cortex-M</h3>
<p>On Cortex-M, the main function is entered using the MSP in Handler mode. After calling <code><a class="el" href="classmodm_1_1fiber_1_1Scheduler.html#a99d4d5f5e7c294607a49023685b2ce65" title="Runs the currently active scheduler. ">modm::fiber::Scheduler::run()</a></code> the PSP is used as a Fiber stack pointer in Thread mode. Therefore all interrupts are using the main stack whose size is defined by the <a href="group__modm__platform__cortex__m.html"><code>modm:platform:cortex-m:main_stack_size</code></a> option and will not increase the fiber stack size at all.</p>
<p>The default stack size is <b>1KiB</b>.</p>
<h3>Hosted</h3>
<p>Two implementations for x86_64 and ARM64 are provided.</p>
<p>The default stack size is <b>1MiB</b>.</p>
<h3>Multi-Core Scheduling</h3>
<p>When using this module in combination with the <code>modm:platform:multicore</code> module, each core gets its own fiber scheduler, which will internally be selected based on the CPU ID. Since the scheduler is not thread-safe, you cannot add fibers from one core to the other. Instead you must construct the fiber without starting it, and when executing on the other core, <code>start()</code> it in that context.</p>
<p>Here is an example for the RP2040 device, which additionally allocates the stack and task into the core-affine memory:</p>
<div class="fragment"><div class="line"><span class="comment">// allocate into core0 memory</span></div>
<div class="line">modm_faststack_core0 <a class="code" href="classmodm_1_1Fiber.html">modm::Fiber&lt;&gt;</a> fiber0(function);</div>
<div class="line"><span class="comment">// allocate into core1 memory but DO NOT start yet!</span></div>
<div class="line">modm_faststack_core1 <a class="code" href="classmodm_1_1Fiber.html">modm::Fiber&lt;&gt;</a> fiber1(function, modm::fiber::Start::Later);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> core1_main()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// start fiber1 in the core1 context!</span></div>
<div class="line">    fiber1.start();</div>
<div class="line">    <a class="code" href="classmodm_1_1fiber_1_1Scheduler.html#a99d4d5f5e7c294607a49023685b2ce65">modm::fiber::Scheduler::run</a>();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    modm::platform::multicore::Core1::run(core1_main);</div>
<div class="line">    <span class="comment">// run fiber0 in core0 context</span></div>
<div class="line">    <a class="code" href="classmodm_1_1fiber_1_1Scheduler.html#a99d4d5f5e7c294607a49023685b2ce65">modm::fiber::Scheduler::run</a>();</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- end fragment -->
 <h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gadeb568e66bd8d41913224531f3f3300c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t StackSize = fiber::StackSizeDefault&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="group__modm__processing__fiber.html#gadeb568e66bd8d41913224531f3f3300c">modm::Fiber::Start</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The <a class="el" href="classmodm_1_1Fiber.html">Fiber</a> scheduling policy. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga7ec71abb103b2967a7afb10fdb081b93"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t StackSize = fiber::StackSizeDefault&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t modm::Fiber&lt; StackSize &gt;::StackSizeDefault = 1024</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The default stack size is estimated experimentally so that a fiber can use <code><a class="el" href="classmodm_1_1IOStream.html">modm::IOStream</a></code> to log out information, which is fairly stack intensive. Use <code><a class="el" href="classmodm_1_1fiber_1_1Task.html#a01e71eded589161c4bf6d04841856f4f">modm::fiber::Task::stack_usage()</a></code> to determine the real stack usage. </p>

</div>
</div>
<a class="anchor" id="ga7ec71abb103b2967a7afb10fdb081b93"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t StackSize = fiber::StackSizeDefault&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t modm::Fiber&lt; StackSize &gt;::StackSizeDefault = 1024</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The default stack size is estimated experimentally so that a fiber can use <code><a class="el" href="classmodm_1_1IOStream.html">modm::IOStream</a></code> to log out information, which is fairly stack intensive. Use <code><a class="el" href="classmodm_1_1fiber_1_1Task.html#a01e71eded589161c4bf6d04841856f4f">modm::fiber::Task::stack_usage()</a></code> to determine the real stack usage. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for DoxyPress 1.3.7-->
<!-- Generated by DoxyPress 1.7.0 -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.copperspice.com/documentation-doxypress.html">
    <img class="footer" src="doxypress.png" alt="DoxyPress"/></a> 1.7.0 </li>
  </ul>
</div>
<script>
if (window.location.href.includes("modm.io")) {
 var device = /\/api\/([a-zA-Z0-9_-]+)\//.exec(window.location.href)[1].toUpperCase();
 document.title = document.title.replace("modm API documentation", "modm API documentation for " + device);
 document.getElementById('projectname').innerHTML = document.getElementById('projectname').innerHTML.replace("modm API documentation", "modm API documentation for " + device);
}
document.getElementById('MSearchResults').onload = function()
{
  var iframe = document.getElementById('MSearchResults').contentWindow.document;
  var head = iframe.getElementsByTagName("head")[0];
  var link = iframe.createElement("link");
  link.setAttribute("rel", "stylesheet");
  link.setAttribute("type", "text/css");
  link.setAttribute("href", "../custom.css");
  head.appendChild(link);
  var link = iframe.createElement("link");
  link.setAttribute("rel", "stylesheet");
  link.setAttribute("type", "text/css");
  link.setAttribute("href", "../custom_dark_theme.css");
  head.appendChild(link);
}
</script>
</body>
</html>
