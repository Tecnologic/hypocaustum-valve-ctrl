<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="DoxyPress 1.7.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>modm API documentation: Fiber Interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxypress.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="custom_dark_theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by DoxyPress -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">modm API documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by DoxyPress 1.7.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__modm__architecture__fiber.html',''); initResizable(); });
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
    <div class="title">Fiber Interface<div class="ingroups"><a class="el" href="group__modm__architecture.html">Architecture Interfaces</a></div></div>
  </div>
  <div class="clear-floats"></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga60d726cfcd7be104bcef2c1258a5f9cc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__architecture__fiber.html#ga60d726cfcd7be104bcef2c1258a5f9cc">modm::Fiber&lt; StackSize &gt;::id</a> = uintptr_t</td></tr>
<tr class="separator:ga60d726cfcd7be104bcef2c1258a5f9cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadaca0b8f126b33ceb0f470a56cc410cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__architecture__fiber.html#gadaca0b8f126b33ceb0f470a56cc410cb">modm::this_fiber::yield</a> ()</td></tr>
<tr class="separator:gadaca0b8f126b33ceb0f470a56cc410cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae97b0b11db2a5cff74703c34e1588e13"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae97b0b11db2a5cff74703c34e1588e13"></a>
modm::fiber::id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__architecture__fiber.html#gae97b0b11db2a5cff74703c34e1588e13">modm::this_fiber::get_id</a> ()</td></tr>
<tr class="memdesc:gae97b0b11db2a5cff74703c34e1588e13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the id of the current fiber. <br /></td></tr>
<tr class="separator:gae97b0b11db2a5cff74703c34e1588e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fe85ec7252e960077434806cbe24e21"><td class="memTemplParams" colspan="2">template&lt;class Function &gt; <br />
requires requires { std::is_invocable_r_v&lt;bool, Function, void&gt;; }</td></tr>
<tr class="memitem:ga7fe85ec7252e960077434806cbe24e21"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__modm__architecture__fiber.html#ga7fe85ec7252e960077434806cbe24e21">modm::this_fiber::poll</a> (Function &amp;&amp;condition)</td></tr>
<tr class="separator:ga7fe85ec7252e960077434806cbe24e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga698331943e029eaaba3c28d23be4343f"><td class="memTemplParams" colspan="2">template&lt;class Rep , class Period , class Function &gt; <br />
requires requires { std::is_invocable_r_v&lt;bool, Function, void&gt;; }</td></tr>
<tr class="memitem:ga698331943e029eaaba3c28d23be4343f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__modm__architecture__fiber.html#ga698331943e029eaaba3c28d23be4343f">modm::this_fiber::poll_for</a> (std::chrono::duration&lt; Rep, Period &gt; sleep_duration, Function &amp;&amp;condition)</td></tr>
<tr class="separator:ga698331943e029eaaba3c28d23be4343f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga547553719207b495c9f7c47eb3391b9d"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="structmodm_1_1chrono_1_1milli__clock.html">Clock</a> , class Duration , class Function &gt; <br />
requires requires { std::is_invocable_r_v&lt;bool, Function, void&gt;; }</td></tr>
<tr class="memitem:ga547553719207b495c9f7c47eb3391b9d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__modm__architecture__fiber.html#ga547553719207b495c9f7c47eb3391b9d">modm::this_fiber::poll_until</a> (std::chrono::time_point&lt; <a class="el" href="structmodm_1_1chrono_1_1milli__clock.html">Clock</a>, Duration &gt; sleep_time, Function &amp;&amp;condition)</td></tr>
<tr class="separator:ga547553719207b495c9f7c47eb3391b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54cfe0c7cf7a5d1cb2dfe13f61d33de2"><td class="memTemplParams" colspan="2">template&lt;class Rep , class Period &gt; </td></tr>
<tr class="memitem:ga54cfe0c7cf7a5d1cb2dfe13f61d33de2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__modm__architecture__fiber.html#ga54cfe0c7cf7a5d1cb2dfe13f61d33de2">modm::this_fiber::sleep_for</a> (std::chrono::duration&lt; Rep, Period &gt; sleep_duration)</td></tr>
<tr class="separator:ga54cfe0c7cf7a5d1cb2dfe13f61d33de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e78739f6eced998f09ce99ef83a104b"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="structmodm_1_1chrono_1_1milli__clock.html">Clock</a> , class Duration &gt; </td></tr>
<tr class="memitem:ga7e78739f6eced998f09ce99ef83a104b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__modm__architecture__fiber.html#ga7e78739f6eced998f09ce99ef83a104b">modm::this_fiber::sleep_until</a> (std::chrono::time_point&lt; <a class="el" href="structmodm_1_1chrono_1_1milli__clock.html">Clock</a>, Duration &gt; sleep_time)</td></tr>
<tr class="separator:ga7e78739f6eced998f09ce99ef83a104b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae97b0b11db2a5cff74703c34e1588e13"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae97b0b11db2a5cff74703c34e1588e13"></a>
modm::fiber::id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__architecture__fiber.html#gae97b0b11db2a5cff74703c34e1588e13">modm::this_fiber::get_id</a> ()</td></tr>
<tr class="memdesc:gae97b0b11db2a5cff74703c34e1588e13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the id of the current fiber. <br /></td></tr>
<tr class="separator:gae97b0b11db2a5cff74703c34e1588e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fe85ec7252e960077434806cbe24e21"><td class="memTemplParams" colspan="2">template&lt;class Function &gt; <br />
requires requires { std::is_invocable_r_v&lt;bool, Function, void&gt;; }</td></tr>
<tr class="memitem:ga7fe85ec7252e960077434806cbe24e21"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__modm__architecture__fiber.html#ga7fe85ec7252e960077434806cbe24e21">modm::this_fiber::poll</a> (Function &amp;&amp;condition)</td></tr>
<tr class="separator:ga7fe85ec7252e960077434806cbe24e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga698331943e029eaaba3c28d23be4343f"><td class="memTemplParams" colspan="2">template&lt;class Rep , class Period , class Function &gt; <br />
requires requires { std::is_invocable_r_v&lt;bool, Function, void&gt;; }</td></tr>
<tr class="memitem:ga698331943e029eaaba3c28d23be4343f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__modm__architecture__fiber.html#ga698331943e029eaaba3c28d23be4343f">modm::this_fiber::poll_for</a> (std::chrono::duration&lt; Rep, Period &gt; sleep_duration, Function &amp;&amp;condition)</td></tr>
<tr class="separator:ga698331943e029eaaba3c28d23be4343f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga547553719207b495c9f7c47eb3391b9d"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="structmodm_1_1chrono_1_1milli__clock.html">Clock</a> , class Duration , class Function &gt; <br />
requires requires { std::is_invocable_r_v&lt;bool, Function, void&gt;; }</td></tr>
<tr class="memitem:ga547553719207b495c9f7c47eb3391b9d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__modm__architecture__fiber.html#ga547553719207b495c9f7c47eb3391b9d">modm::this_fiber::poll_until</a> (std::chrono::time_point&lt; <a class="el" href="structmodm_1_1chrono_1_1milli__clock.html">Clock</a>, Duration &gt; sleep_time, Function &amp;&amp;condition)</td></tr>
<tr class="separator:ga547553719207b495c9f7c47eb3391b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54cfe0c7cf7a5d1cb2dfe13f61d33de2"><td class="memTemplParams" colspan="2">template&lt;class Rep , class Period &gt; </td></tr>
<tr class="memitem:ga54cfe0c7cf7a5d1cb2dfe13f61d33de2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__modm__architecture__fiber.html#ga54cfe0c7cf7a5d1cb2dfe13f61d33de2">modm::this_fiber::sleep_for</a> (std::chrono::duration&lt; Rep, Period &gt; sleep_duration)</td></tr>
<tr class="separator:ga54cfe0c7cf7a5d1cb2dfe13f61d33de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e78739f6eced998f09ce99ef83a104b"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="structmodm_1_1chrono_1_1milli__clock.html">Clock</a> , class Duration &gt; </td></tr>
<tr class="memitem:ga7e78739f6eced998f09ce99ef83a104b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__modm__architecture__fiber.html#ga7e78739f6eced998f09ce99ef83a104b">modm::this_fiber::sleep_until</a> (std::chrono::time_point&lt; <a class="el" href="structmodm_1_1chrono_1_1milli__clock.html">Clock</a>, Duration &gt; sleep_time)</td></tr>
<tr class="separator:ga7e78739f6eced998f09ce99ef83a104b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>lbuild module: <code>modm:architecture:fiber</code></p>
<p>This module provides an interface to yield control back to a scheduler. The basic functionality is provided by the <code><a class="el" href="group__modm__architecture__fiber.html#gadaca0b8f126b33ceb0f470a56cc410cb">yield()</a></code> function which transparently gives control back to the scheduler and returns afterwards. It is particularly important to yield in long running loops to prevent the system from locking up by preventing other fibers from making progress:</p>
<div class="fragment"><div class="line"><span class="keywordflow">while</span>(<span class="keyword">true</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// run your code here</span></div>
<div class="line">    <span class="comment">// but always yield to other fibers whenever possible</span></div>
<div class="line">    <a class="code" href="group__modm__architecture__fiber.html#gadaca0b8f126b33ceb0f470a56cc410cb">modm::this_fiber::yield</a>();</div>
<div class="line">}</div>
</div><!-- end fragment -->
<p>For convenience a <code><a class="el" href="group__modm__architecture__fiber.html#ga7fe85ec7252e960077434806cbe24e21">poll()</a></code> function is provided that can be used to yield until a condition is met:</p>
<div class="fragment"><div class="line"><a class="code" href="group__modm__architecture__fiber.html#ga7fe85ec7252e960077434806cbe24e21">modm::this_fiber::poll</a>([&amp;]{ <span class="keywordflow">return</span> condition; });</div>
</div><!-- end fragment -->
<p>An extension of this concept is provided by the <code><a class="el" href="group__modm__architecture__fiber.html#ga698331943e029eaaba3c28d23be4343f">poll_for()</a></code> and <code><a class="el" href="group__modm__architecture__fiber.html#ga547553719207b495c9f7c47eb3391b9d">poll_until()</a></code> functions, which yield until the condition is met or until a timeout occurs:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> condition_met = <a class="code" href="group__modm__architecture__fiber.html#ga698331943e029eaaba3c28d23be4343f">modm::this_fiber::poll_for</a>(1s, [&amp;]{ <span class="keywordflow">return</span> condition; });</div>
<div class="line"><span class="comment">// if (not condition_met) condition did not return true for 1s.</span></div>
</div><!-- end fragment -->
<p>If microseconds are passed for the duration, the functions use the <code><a class="el" href="structmodm_1_1chrono_1_1micro__clock.html">modm::chrono::micro_clock</a></code> (=<code>modm::PreciseClock</code>), otherwise they use <code><a class="el" href="structmodm_1_1chrono_1_1milli__clock.html">modm::chrono::milli_clock</a></code> (=<code>modm::Clock</code>). This requires that these clocks are already initialized and running.</p>
<p>These basic building blocks are then used to implement the <code><a class="el" href="group__modm__architecture__fiber.html#ga54cfe0c7cf7a5d1cb2dfe13f61d33de2">sleep_for()</a></code> and <code><a class="el" href="group__modm__architecture__fiber.html#ga7e78739f6eced998f09ce99ef83a104b">sleep_until()</a></code> convenience functions:</p>
<div class="fragment"><div class="line"><a class="code" href="group__modm__architecture__fiber.html#ga54cfe0c7cf7a5d1cb2dfe13f61d33de2">modm::this_fiber::sleep_for</a>(1s);</div>
</div><!-- end fragment -->
<h2>Implementation</h2>
<p>The <code><a class="el" href="group__modm__architecture__fiber.html#gadaca0b8f126b33ceb0f470a56cc410cb">yield()</a></code> function is implemented by the <a href="group__modm__processing__fiber.html"><code>modm:processing:fiber</code></a> module which provides a cooperative multitasking scheduler that is able to switch between multiple fiber contexts.</p>
<p>If <code><a class="el" href="group__modm__architecture__fiber.html#gadaca0b8f126b33ceb0f470a56cc410cb">yield()</a></code> is called outside of a fiber context, for example, in the <code>main()</code> function when the scheduler is not yet running, <code><a class="el" href="group__modm__architecture__fiber.html#gadaca0b8f126b33ceb0f470a56cc410cb">yield()</a></code> will return in-place. This mechanism allows for a graceful fallback to a blocking API without changes to the code using <code><a class="el" href="group__modm__architecture__fiber.html#gadaca0b8f126b33ceb0f470a56cc410cb">yield()</a></code>.</p>
<div class="fragment"><div class="line"><a class="code" href="classmodm_1_1Fiber.html">modm::Fiber</a> fiber_nonblocking([]</div>
<div class="line">{</div>
<div class="line">    modm::Timeout timeout(100ms);</div>
<div class="line">    timeout.wait(); <span class="comment">// non-blocking call!</span></div>
<div class="line">});</div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    modm::Timeout timeout(100ms);</div>
<div class="line">    timeout.wait(); <span class="comment">// blocking call!</span></div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classmodm_1_1fiber_1_1Scheduler.html#a99d4d5f5e7c294607a49023685b2ce65">modm::fiber::Scheduler::run</a>()</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- end fragment -->
<p>This mechanism also supports running modm on devices with very small memories where a stackful scheduler may be to resource intensive: The <a href="group__modm__processing__fiber.html"><code>modm:processing:fiber</code></a> module is strictly opt-in and if not selected the scheduler is not included and the <code><a class="el" href="group__modm__architecture__fiber.html#gadaca0b8f126b33ceb0f470a56cc410cb">yield()</a></code> function is implemented as an empty stub while still allowing for the whole API to be used without changes:</p>
<div class="fragment"><div class="line">modm::Lis3mdl&lt;I2cMaster1&gt; sensor{};</div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    sensor.configure(); <span class="comment">// blocking but works just fine</span></div>
<div class="line">    <span class="keywordflow">while</span>(<span class="keyword">true</span>)</div>
<div class="line">    {</div>
<div class="line">        modm::Vector3f magVector;</div>
<div class="line">        sensor.readMagnetometer(magVector); <span class="comment">// another blocking call</span></div>
<div class="line">        <a class="code" href="group__modm__architecture__fiber.html#ga54cfe0c7cf7a5d1cb2dfe13f61d33de2">modm::this_fiber::sleep_for</a>(10ms); <span class="comment">// this will wait in place</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- end fragment -->
<p>Therefore, if you use these functions in your code, only depend on <a href="group__modm__architecture__fiber.html"><code>modm:architecture:fiber</code></a> and let the user decide on the implementation by including <a href="group__modm__processing__fiber.html"><code>modm:processing:fiber</code></a> or not. This compromise allows for a seamless transition between different devices and scheduling strategies.</p>
<h2>Identifier</h2>
<p>You can check what fiber your code is executed in by calling the <code><a class="el" href="group__modm__architecture__fiber.html#gae97b0b11db2a5cff74703c34e1588e13" title="Returns the id of the current fiber. ">get_id()</a></code> function:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> <span class="keywordtype">id</span> = <a class="code" href="group__modm__architecture__fiber.html#gae97b0b11db2a5cff74703c34e1588e13">modm::this_fiber::get_id</a>();</div>
<div class="line"><span class="comment">// if (id == 0) called outside a fiber</span></div>
<div class="line"><span class="comment">// else called from inside a fiber</span></div>
</div><!-- end fragment -->
<p>The returned ID is the address of the currently running fiber object. If called outside of a fiber, for example, in the main function before the scheduler is running, the function returns <code>0</code>. The implementation ensures that all returned values are unique and thus allow the ID to be used for tracking ownership of various recursive locks, for example. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga60d726cfcd7be104bcef2c1258a5f9cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t StackSize = fiber::StackSizeDefault&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using modm::Fiber&lt; StackSize &gt;::<a class="el" href="group__modm__architecture__fiber.html#ga60d726cfcd7be104bcef2c1258a5f9cc">id</a> =  uintptr_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identifier of a fiber task. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga7fe85ec7252e960077434806cbe24e21"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Function &gt; <br />
requires requires { std::is_invocable_r_v&lt;bool, Function, void&gt;; }</div>
      <table class="memname">
        <tr>
          <td class="memname">void modm::this_fiber::poll </td>
          <td>(</td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>condition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Yields the current fiber until <code>bool condition()</code> returns true. </p><dl class="section warning"><dt>Warning</dt><dd>If <code>bool condition()</code> is true on first call, no yield is performed! </dd></dl>
<span class="requiresdoc">Constraint</span> requires requires { std::is_invocable_r_v&lt;bool, Function, void&gt;; }
</div>
</div>
<a class="anchor" id="ga7fe85ec7252e960077434806cbe24e21"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Function &gt; <br />
requires requires { std::is_invocable_r_v&lt;bool, Function, void&gt;; }</div>
      <table class="memname">
        <tr>
          <td class="memname">void modm::this_fiber::poll </td>
          <td>(</td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>condition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Yields the current fiber until <code>bool condition()</code> returns true. </p><dl class="section warning"><dt>Warning</dt><dd>If <code>bool condition()</code> is true on first call, no yield is performed! </dd></dl>
<span class="requiresdoc">Constraint</span> requires requires { std::is_invocable_r_v&lt;bool, Function, void&gt;; }
</div>
</div>
<a class="anchor" id="ga7fe85ec7252e960077434806cbe24e21"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Function &gt; <br />
requires requires { std::is_invocable_r_v&lt;bool, Function, void&gt;; }</div>
      <table class="memname">
        <tr>
          <td class="memname">void modm::this_fiber::poll </td>
          <td>(</td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>condition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Yields the current fiber until <code>bool condition()</code> returns true. </p><dl class="section warning"><dt>Warning</dt><dd>If <code>bool condition()</code> is true on first call, no yield is performed! </dd></dl>
<span class="requiresdoc">Constraint</span> requires requires { std::is_invocable_r_v&lt;bool, Function, void&gt;; }
</div>
</div>
<a class="anchor" id="ga7fe85ec7252e960077434806cbe24e21"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Function &gt; <br />
requires requires { std::is_invocable_r_v&lt;bool, Function, void&gt;; }</div>
      <table class="memname">
        <tr>
          <td class="memname">void modm::this_fiber::poll </td>
          <td>(</td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>condition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Yields the current fiber until <code>bool condition()</code> returns true. </p><dl class="section warning"><dt>Warning</dt><dd>If <code>bool condition()</code> is true on first call, no yield is performed! </dd></dl>
<span class="requiresdoc">Constraint</span> requires requires { std::is_invocable_r_v&lt;bool, Function, void&gt;; }
</div>
</div>
<a class="anchor" id="ga698331943e029eaaba3c28d23be4343f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Rep , class Period , class Function &gt; <br />
requires requires { std::is_invocable_r_v&lt;bool, Function, void&gt;; }</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool modm::this_fiber::poll_for </td>
          <td>(</td>
          <td class="paramtype">std::chrono::duration&lt; Rep, Period &gt;&#160;</td>
          <td class="paramname"><em>sleep_duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Yields the current fiber until <code>bool condition()</code> returns true or the time duration has elapsed.</p>
<dl class="section warning"><dt>Warning</dt><dd>If <code>bool condition()</code> is true on first call, no yield is performed!</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the condition was met, <code>false</code> if the time duration has elapsed.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Due to the overhead of <code><a class="el" href="group__modm__architecture__fiber.html#gadaca0b8f126b33ceb0f470a56cc410cb">yield()</a></code> and the scheduling other fibers, the sleep duration may be longer without any guarantee of an upper limit. </dd></dl>
<span class="requiresdoc">Constraint</span> requires requires { std::is_invocable_r_v&lt;bool, Function, void&gt;; }
</div>
</div>
<a class="anchor" id="ga698331943e029eaaba3c28d23be4343f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Rep , class Period , class Function &gt; <br />
requires requires { std::is_invocable_r_v&lt;bool, Function, void&gt;; }</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool modm::this_fiber::poll_for </td>
          <td>(</td>
          <td class="paramtype">std::chrono::duration&lt; Rep, Period &gt;&#160;</td>
          <td class="paramname"><em>sleep_duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Yields the current fiber until <code>bool condition()</code> returns true or the time duration has elapsed.</p>
<dl class="section warning"><dt>Warning</dt><dd>If <code>bool condition()</code> is true on first call, no yield is performed!</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the condition was met, <code>false</code> if the time duration has elapsed.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Due to the overhead of <code><a class="el" href="group__modm__architecture__fiber.html#gadaca0b8f126b33ceb0f470a56cc410cb">yield()</a></code> and the scheduling other fibers, the sleep duration may be longer without any guarantee of an upper limit. </dd></dl>
<span class="requiresdoc">Constraint</span> requires requires { std::is_invocable_r_v&lt;bool, Function, void&gt;; }
</div>
</div>
<a class="anchor" id="ga698331943e029eaaba3c28d23be4343f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Rep , class Period , class Function &gt; <br />
requires requires { std::is_invocable_r_v&lt;bool, Function, void&gt;; }</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool modm::this_fiber::poll_for </td>
          <td>(</td>
          <td class="paramtype">std::chrono::duration&lt; Rep, Period &gt;&#160;</td>
          <td class="paramname"><em>sleep_duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Yields the current fiber until <code>bool condition()</code> returns true or the time duration has elapsed.</p>
<dl class="section warning"><dt>Warning</dt><dd>If <code>bool condition()</code> is true on first call, no yield is performed!</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the condition was met, <code>false</code> if the time duration has elapsed.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Due to the overhead of <code><a class="el" href="group__modm__architecture__fiber.html#gadaca0b8f126b33ceb0f470a56cc410cb">yield()</a></code> and the scheduling other fibers, the sleep duration may be longer without any guarantee of an upper limit. </dd></dl>
<span class="requiresdoc">Constraint</span> requires requires { std::is_invocable_r_v&lt;bool, Function, void&gt;; }
</div>
</div>
<a class="anchor" id="ga698331943e029eaaba3c28d23be4343f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Rep , class Period , class Function &gt; <br />
requires requires { std::is_invocable_r_v&lt;bool, Function, void&gt;; }</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool modm::this_fiber::poll_for </td>
          <td>(</td>
          <td class="paramtype">std::chrono::duration&lt; Rep, Period &gt;&#160;</td>
          <td class="paramname"><em>sleep_duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Yields the current fiber until <code>bool condition()</code> returns true or the time duration has elapsed.</p>
<dl class="section warning"><dt>Warning</dt><dd>If <code>bool condition()</code> is true on first call, no yield is performed!</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the condition was met, <code>false</code> if the time duration has elapsed.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Due to the overhead of <code><a class="el" href="group__modm__architecture__fiber.html#gadaca0b8f126b33ceb0f470a56cc410cb">yield()</a></code> and the scheduling other fibers, the sleep duration may be longer without any guarantee of an upper limit. </dd></dl>
<span class="requiresdoc">Constraint</span> requires requires { std::is_invocable_r_v&lt;bool, Function, void&gt;; }
</div>
</div>
<a class="anchor" id="ga547553719207b495c9f7c47eb3391b9d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="structmodm_1_1chrono_1_1milli__clock.html">Clock</a> , class Duration , class Function &gt; <br />
requires requires { std::is_invocable_r_v&lt;bool, Function, void&gt;; }</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool modm::this_fiber::poll_until </td>
          <td>(</td>
          <td class="paramtype">std::chrono::time_point&lt; <a class="el" href="structmodm_1_1chrono_1_1milli__clock.html">Clock</a>, Duration &gt;&#160;</td>
          <td class="paramname"><em>sleep_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Yields the current fiber until <code>bool condition()</code> returns true or the sleep time has been reached.</p>
<dl class="section warning"><dt>Warning</dt><dd>If <code>bool condition()</code> is true on first call, no yield is performed!</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the condition was met, <code>false</code> if the sleep time has elapsed.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Due to the overhead of <code><a class="el" href="group__modm__architecture__fiber.html#gadaca0b8f126b33ceb0f470a56cc410cb">yield()</a></code> and the scheduling other fibers, the sleep duration may be longer without any guarantee of an upper limit. </dd></dl>
<span class="requiresdoc">Constraint</span> requires requires { std::is_invocable_r_v&lt;bool, Function, void&gt;; }
</div>
</div>
<a class="anchor" id="ga547553719207b495c9f7c47eb3391b9d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="structmodm_1_1chrono_1_1milli__clock.html">Clock</a> , class Duration , class Function &gt; <br />
requires requires { std::is_invocable_r_v&lt;bool, Function, void&gt;; }</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool modm::this_fiber::poll_until </td>
          <td>(</td>
          <td class="paramtype">std::chrono::time_point&lt; <a class="el" href="structmodm_1_1chrono_1_1milli__clock.html">Clock</a>, Duration &gt;&#160;</td>
          <td class="paramname"><em>sleep_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Yields the current fiber until <code>bool condition()</code> returns true or the sleep time has been reached.</p>
<dl class="section warning"><dt>Warning</dt><dd>If <code>bool condition()</code> is true on first call, no yield is performed!</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the condition was met, <code>false</code> if the sleep time has elapsed.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Due to the overhead of <code><a class="el" href="group__modm__architecture__fiber.html#gadaca0b8f126b33ceb0f470a56cc410cb">yield()</a></code> and the scheduling other fibers, the sleep duration may be longer without any guarantee of an upper limit. </dd></dl>
<span class="requiresdoc">Constraint</span> requires requires { std::is_invocable_r_v&lt;bool, Function, void&gt;; }
</div>
</div>
<a class="anchor" id="ga547553719207b495c9f7c47eb3391b9d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="structmodm_1_1chrono_1_1milli__clock.html">Clock</a> , class Duration , class Function &gt; <br />
requires requires { std::is_invocable_r_v&lt;bool, Function, void&gt;; }</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool modm::this_fiber::poll_until </td>
          <td>(</td>
          <td class="paramtype">std::chrono::time_point&lt; <a class="el" href="structmodm_1_1chrono_1_1milli__clock.html">Clock</a>, Duration &gt;&#160;</td>
          <td class="paramname"><em>sleep_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Yields the current fiber until <code>bool condition()</code> returns true or the sleep time has been reached.</p>
<dl class="section warning"><dt>Warning</dt><dd>If <code>bool condition()</code> is true on first call, no yield is performed!</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the condition was met, <code>false</code> if the sleep time has elapsed.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Due to the overhead of <code><a class="el" href="group__modm__architecture__fiber.html#gadaca0b8f126b33ceb0f470a56cc410cb">yield()</a></code> and the scheduling other fibers, the sleep duration may be longer without any guarantee of an upper limit. </dd></dl>
<span class="requiresdoc">Constraint</span> requires requires { std::is_invocable_r_v&lt;bool, Function, void&gt;; }
</div>
</div>
<a class="anchor" id="ga547553719207b495c9f7c47eb3391b9d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="structmodm_1_1chrono_1_1milli__clock.html">Clock</a> , class Duration , class Function &gt; <br />
requires requires { std::is_invocable_r_v&lt;bool, Function, void&gt;; }</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool modm::this_fiber::poll_until </td>
          <td>(</td>
          <td class="paramtype">std::chrono::time_point&lt; <a class="el" href="structmodm_1_1chrono_1_1milli__clock.html">Clock</a>, Duration &gt;&#160;</td>
          <td class="paramname"><em>sleep_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Yields the current fiber until <code>bool condition()</code> returns true or the sleep time has been reached.</p>
<dl class="section warning"><dt>Warning</dt><dd>If <code>bool condition()</code> is true on first call, no yield is performed!</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the condition was met, <code>false</code> if the sleep time has elapsed.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Due to the overhead of <code><a class="el" href="group__modm__architecture__fiber.html#gadaca0b8f126b33ceb0f470a56cc410cb">yield()</a></code> and the scheduling other fibers, the sleep duration may be longer without any guarantee of an upper limit. </dd></dl>
<span class="requiresdoc">Constraint</span> requires requires { std::is_invocable_r_v&lt;bool, Function, void&gt;; }
</div>
</div>
<a class="anchor" id="ga54cfe0c7cf7a5d1cb2dfe13f61d33de2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Rep , class Period &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void modm::this_fiber::sleep_for </td>
          <td>(</td>
          <td class="paramtype">std::chrono::duration&lt; Rep, Period &gt;&#160;</td>
          <td class="paramname"><em>sleep_duration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Yields the current fiber until the time duration has elapsed.</p>
<dl class="section note"><dt>Note</dt><dd>For nanosecond delays, use <code>modm::delay(ns)</code>. </dd>
<dd>
Due to the overhead of <code><a class="el" href="group__modm__architecture__fiber.html#gadaca0b8f126b33ceb0f470a56cc410cb">yield()</a></code> and the scheduling other fibers, the sleep duration may be longer without any guarantee of an upper limit. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.cppreference.com/w/cpp/thread/sleep_for">https://en.cppreference.com/w/cpp/thread/sleep_for</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga54cfe0c7cf7a5d1cb2dfe13f61d33de2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Rep , class Period &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void modm::this_fiber::sleep_for </td>
          <td>(</td>
          <td class="paramtype">std::chrono::duration&lt; Rep, Period &gt;&#160;</td>
          <td class="paramname"><em>sleep_duration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Yields the current fiber until the time duration has elapsed.</p>
<dl class="section note"><dt>Note</dt><dd>For nanosecond delays, use <code>modm::delay(ns)</code>. </dd>
<dd>
Due to the overhead of <code><a class="el" href="group__modm__architecture__fiber.html#gadaca0b8f126b33ceb0f470a56cc410cb">yield()</a></code> and the scheduling other fibers, the sleep duration may be longer without any guarantee of an upper limit. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.cppreference.com/w/cpp/thread/sleep_for">https://en.cppreference.com/w/cpp/thread/sleep_for</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga54cfe0c7cf7a5d1cb2dfe13f61d33de2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Rep , class Period &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void modm::this_fiber::sleep_for </td>
          <td>(</td>
          <td class="paramtype">std::chrono::duration&lt; Rep, Period &gt;&#160;</td>
          <td class="paramname"><em>sleep_duration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Yields the current fiber until the time duration has elapsed.</p>
<dl class="section note"><dt>Note</dt><dd>For nanosecond delays, use <code>modm::delay(ns)</code>. </dd>
<dd>
Due to the overhead of <code><a class="el" href="group__modm__architecture__fiber.html#gadaca0b8f126b33ceb0f470a56cc410cb">yield()</a></code> and the scheduling other fibers, the sleep duration may be longer without any guarantee of an upper limit. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.cppreference.com/w/cpp/thread/sleep_for">https://en.cppreference.com/w/cpp/thread/sleep_for</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga54cfe0c7cf7a5d1cb2dfe13f61d33de2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Rep , class Period &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void modm::this_fiber::sleep_for </td>
          <td>(</td>
          <td class="paramtype">std::chrono::duration&lt; Rep, Period &gt;&#160;</td>
          <td class="paramname"><em>sleep_duration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Yields the current fiber until the time duration has elapsed.</p>
<dl class="section note"><dt>Note</dt><dd>For nanosecond delays, use <code>modm::delay(ns)</code>. </dd>
<dd>
Due to the overhead of <code><a class="el" href="group__modm__architecture__fiber.html#gadaca0b8f126b33ceb0f470a56cc410cb">yield()</a></code> and the scheduling other fibers, the sleep duration may be longer without any guarantee of an upper limit. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.cppreference.com/w/cpp/thread/sleep_for">https://en.cppreference.com/w/cpp/thread/sleep_for</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7e78739f6eced998f09ce99ef83a104b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="structmodm_1_1chrono_1_1milli__clock.html">Clock</a> , class Duration &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void modm::this_fiber::sleep_until </td>
          <td>(</td>
          <td class="paramtype">std::chrono::time_point&lt; <a class="el" href="structmodm_1_1chrono_1_1milli__clock.html">Clock</a>, Duration &gt;&#160;</td>
          <td class="paramname"><em>sleep_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Yields the current fiber until the sleep time has been reached.</p>
<dl class="section note"><dt>Note</dt><dd>Due to the overhead of <code><a class="el" href="group__modm__architecture__fiber.html#gadaca0b8f126b33ceb0f470a56cc410cb">yield()</a></code> and the scheduling other fibers, the sleep duration may be longer without any guarantee of an upper limit. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.cppreference.com/w/cpp/thread/sleep_until">https://en.cppreference.com/w/cpp/thread/sleep_until</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7e78739f6eced998f09ce99ef83a104b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="structmodm_1_1chrono_1_1milli__clock.html">Clock</a> , class Duration &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void modm::this_fiber::sleep_until </td>
          <td>(</td>
          <td class="paramtype">std::chrono::time_point&lt; <a class="el" href="structmodm_1_1chrono_1_1milli__clock.html">Clock</a>, Duration &gt;&#160;</td>
          <td class="paramname"><em>sleep_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Yields the current fiber until the sleep time has been reached.</p>
<dl class="section note"><dt>Note</dt><dd>Due to the overhead of <code><a class="el" href="group__modm__architecture__fiber.html#gadaca0b8f126b33ceb0f470a56cc410cb">yield()</a></code> and the scheduling other fibers, the sleep duration may be longer without any guarantee of an upper limit. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.cppreference.com/w/cpp/thread/sleep_until">https://en.cppreference.com/w/cpp/thread/sleep_until</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7e78739f6eced998f09ce99ef83a104b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="structmodm_1_1chrono_1_1milli__clock.html">Clock</a> , class Duration &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void modm::this_fiber::sleep_until </td>
          <td>(</td>
          <td class="paramtype">std::chrono::time_point&lt; <a class="el" href="structmodm_1_1chrono_1_1milli__clock.html">Clock</a>, Duration &gt;&#160;</td>
          <td class="paramname"><em>sleep_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Yields the current fiber until the sleep time has been reached.</p>
<dl class="section note"><dt>Note</dt><dd>Due to the overhead of <code><a class="el" href="group__modm__architecture__fiber.html#gadaca0b8f126b33ceb0f470a56cc410cb">yield()</a></code> and the scheduling other fibers, the sleep duration may be longer without any guarantee of an upper limit. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.cppreference.com/w/cpp/thread/sleep_until">https://en.cppreference.com/w/cpp/thread/sleep_until</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7e78739f6eced998f09ce99ef83a104b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="structmodm_1_1chrono_1_1milli__clock.html">Clock</a> , class Duration &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void modm::this_fiber::sleep_until </td>
          <td>(</td>
          <td class="paramtype">std::chrono::time_point&lt; <a class="el" href="structmodm_1_1chrono_1_1milli__clock.html">Clock</a>, Duration &gt;&#160;</td>
          <td class="paramname"><em>sleep_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Yields the current fiber until the sleep time has been reached.</p>
<dl class="section note"><dt>Note</dt><dd>Due to the overhead of <code><a class="el" href="group__modm__architecture__fiber.html#gadaca0b8f126b33ceb0f470a56cc410cb">yield()</a></code> and the scheduling other fibers, the sleep duration may be longer without any guarantee of an upper limit. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.cppreference.com/w/cpp/thread/sleep_until">https://en.cppreference.com/w/cpp/thread/sleep_until</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gadaca0b8f126b33ceb0f470a56cc410cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void modm::this_fiber::yield </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls into the currently active scheduler to jump to the next fiber. Local control flow resumes by returning from this function.</p>
<dl class="section note"><dt>Note</dt><dd>If called while no scheduler is active, or only one fiber is currently running, this function returns immediately without performing a jump. This can cause deadlocks if the calling fiber waits on progress made outside of it.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Be careful to yield inside long running loops or when busy-waiting. These are cooperative fibers, so the scheduler will not preempt fibers, and you may starve other fibers of processing time. If you cannot guarantee correct timings, consider using an RTOS. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for DoxyPress 1.3.7-->
<!-- Generated by DoxyPress 1.7.0 -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.copperspice.com/documentation-doxypress.html">
    <img class="footer" src="doxypress.png" alt="DoxyPress"/></a> 1.7.0 </li>
  </ul>
</div>
<script>
if (window.location.href.includes("modm.io")) {
 var device = /\/api\/([a-zA-Z0-9_-]+)\//.exec(window.location.href)[1].toUpperCase();
 document.title = document.title.replace("modm API documentation", "modm API documentation for " + device);
 document.getElementById('projectname').innerHTML = document.getElementById('projectname').innerHTML.replace("modm API documentation", "modm API documentation for " + device);
}
document.getElementById('MSearchResults').onload = function()
{
  var iframe = document.getElementById('MSearchResults').contentWindow.document;
  var head = iframe.getElementsByTagName("head")[0];
  var link = iframe.createElement("link");
  link.setAttribute("rel", "stylesheet");
  link.setAttribute("type", "text/css");
  link.setAttribute("href", "../custom.css");
  head.appendChild(link);
  var link = iframe.createElement("link");
  link.setAttribute("rel", "stylesheet");
  link.setAttribute("type", "text/css");
  link.setAttribute("href", "../custom_dark_theme.css");
  head.appendChild(link);
}
</script>
</body>
</html>
